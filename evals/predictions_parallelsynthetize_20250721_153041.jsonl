{"instance_id": "django__django-11039", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -37,7 +37,7 @@\n         migration = loader.get_migration(app_label, migration_name)\n \n         # Set transaction pending status\n-        self.output_transaction = migration.atomic\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a new schema editor for the connection\n         editor = connection.schema_editor(atomic=self.output_transaction, collect_sql=True)\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -1,5 +1,6 @@\n import io\n import os\n import sys\n+from unittest import mock\n \n from django.apps import apps\n from django.core.management import CommandError, call_command\n@@ -531,6 +532,22 @@\n         output = out.getvalue()\n         self.assertNotIn(self.TRANSACTION_START, output)\n         self.assertNotIn(self.TRANSACTION_END, output)\n+\n+    @mock.patch.object(connection.features, 'can_rollback_ddl', False)\n+    def test_sqlmigrate_for_db_that_doesnt_support_ddl_transactions(self):\n+        \"\"\"\n+        sqlmigrate doesn't wrap migrations in a transaction on databases that\n+        don't support transactional DDL.\n+        \"\"\"\n+        # We need to launch `migrate` so the migration is available\n+        # for `sqlmigrate`.\n+        call_command('migrate', 'migrations', '0001', verbosity=0)\n+        out = io.StringIO()\n+        # Get the output of sqlmigrate\n+        call_command('sqlmigrate', 'migrations', '0001', stdout=out)\n+        output = out.getvalue()\n+        self.assertNotIn(self.TRANSACTION_START, output)\n+        self.assertNotIn(self.TRANSACTION_END, output)\n \n     def test_sqlmigrate_app_label_no_migration_number(self):\n         \"\"\"\n\n```"}
