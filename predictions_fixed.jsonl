{"instance_id": "astropy__astropy-12907", "prediction": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex b2c8b0f..4c15a6b 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -21,42 +21,37 @@\n     \"\"\"\n \n     if not model.fittable and model.n_inputs > 0:\n         return np.ones((model.n_outputs, model.n_inputs), dtype=bool)\n \n-    if not isinstance(model, CompoundModel):\n-        if model.n_inputs == 0:\n-            return np.empty((model.n_outputs, 0), dtype=bool)\n-        # TODO: This doesn't handle multidimensional separable models\n-        # correctly\n-        if model.separable:\n-            return np.diag(np.ones(model.n_inputs, dtype=bool))\n-        else:\n-            return np.ones((model.n_outputs, model.n_inputs), dtype=bool)\n+    if isinstance(model, CompoundModel):\n+        # Handle CompoundModel with &, |, and >> operators\n+        op = model.op\n \n-    # Now for the more complicated part: CompoundModel\n-    # For now this only supports compound models made with &, |, and >>\n-    # It might be possible to support other operators like +, -, *, etc. but\n-    # for now this will suffice.\n-    op = model.op\n+        if op == '&':\n+            # Block-diagonal matrix for & operator\n+            left_sep = separability_matrix(model.left)\n+            right_sep = separability_matrix(model.right)\n+            result = np.zeros((model.n_outputs, model.n_inputs), dtype=bool)\n+            result[:left_sep.shape[0], :left_sep.shape[1]] = left_sep\n+            result[left_sep.shape[0]:, left_sep.shape[1]:] = right_sep\n+            return result\n+        elif op in ('|', '>>'):\n+            # Dot product for | and >> operators\n+            left_sep = separability_matrix(model.left)\n+            right_sep = separability_matrix(model.right)\n+            return np.dot(right_sep, left_sep).astype(bool)\n+        else:\n+            # Fallback for other operators\n+            return np.ones((model.n_outputs, model.n_inputs), dtype=bool)\n \n-    if op == '&':\n-        # For the & operator, the separability matrix is a block-diagonal\n-        # matrix of the separability matrices of the two sub-models\n-        left_sep = separability_matrix(model.left)\n-        right_sep = separability_matrix(model.right)\n-        result = np.zeros((model.n_outputs, model.n_inputs), dtype=bool)\n-        result[:left_sep.shape[0], :left_sep.shape[1]] = left_sep\n-        result[left_sep.shape[0]:, left_sep.shape[1]:] = right_sep\n-        return result\n-    elif op in ('|', '>>'):\n-        # For the | and >> operators, the separability matrix is the dot\n-        # product of the separability matrices of the two sub-models\n-        left_sep = separability_matrix(model.left)\n-        right_sep = separability_matrix(model.right)\n-        return np.dot(right_sep, left_sep).astype(bool)\n-    else:\n-        # Fallback for other operators: Assume all outputs depend on all\n-        # inputs\n+    if model.n_inputs == 0:\n+        return np.empty((model.n_outputs, 0), dtype=bool)\n+    # Handle non-CompoundModel cases\n+    if model.separable:\n+        return np.diag(np.ones(model.n_inputs, dtype=bool))\n+    else:\n         return np.ones((model.n_outputs, model.n_inputs), dtype=bool)", "model_name_or_path": "parallelsynthetize_route"}
