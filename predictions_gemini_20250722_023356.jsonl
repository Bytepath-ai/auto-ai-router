{"instance_id": "astropy__astropy-12907", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1012,19 +1012,13 @@\n \n         if op == '&':\n             if isinstance(left, CompoundModel) and left.op == '&':\n-                if isinstance(right, CompoundModel) and right.op == '&':\n-                    # Both are compound models with &\n-                    # TODO: This should be made to use a list of models\n-                    # instead of a binary tree\n-                    self.left = left\n-                    self.right = right\n-                else:\n-                    # Left is a compound model, right is a basic model\n-                    self.left = left\n-                    self.right = right\n+                self.left = left\n+                self.right = right\n             elif isinstance(right, CompoundModel) and right.op == '&':\n                 # Left is a basic model, right is a compound model\n-                # Swap them\n-                self.left = right\n-                self.right = left\n+                # Flatten the tree\n+                self.left = CompoundModel('&', left, right.left)\n+                self.right = right.right\n             else:\n                 # Both are basic models\n                 self.left = left\n\n```"}
{"instance_id": "astropy__astropy-14182", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/io/ascii/core.py\n+++ b/astropy/io/ascii/core.py\n@@ -1473,10 +1473,29 @@\n \n     def write(self, lines):\n         if not self.cols:\n             return\n-        self.data.header.write(lines)  # Write the data header line\n-        lines.append(self.str_vals([col.name for col in self.cols]))\n-        lines.append(lines[-2])\n+\n+        if self.header_rows is None:\n+            self.header_rows = ['name']\n+            if any(col.unit for col in self.cols):\n+                self.header_rows.append('unit')\n+\n+        # Write the top header line\n+        self.data.header.write(lines)\n+\n+        for row_name in self.header_rows:\n+            if row_name == 'name':\n+                vals = [col.name for col in self.cols]\n+            elif row_name == 'unit':\n+                vals = [col.unit or '' for col in self.cols]\n+            elif row_name == 'dtype':\n+                vals = [col.dtype or '' for col in self.cols]\n+            elif row_name == 'format':\n+                vals = [col.format or '' for col in self.cols]\n+            elif row_name == 'description':\n+                vals = [col.description or '' for col in self.cols]\n+            elif row_name == 'meta':\n+                vals = [json.dumps(col.meta) or '' for col in self.cols]\n+            else:\n+                raise ValueError(f\"row_name {row_name!r} is not supported\")\n+            lines.append(self.str_vals(vals))\n+\n+        # Write the bottom header line\n+        lines.append(lines[-(len(self.header_rows) + 1)])\n \n \n class RstData(BaseData):\n@@ -1519,3 +1538,8 @@\n     data_class = RstData\n     # rst tables do not have a comment line syntax\n     comment = None\n+\n+    def __init__(self, header_rows=None):\n+        super().__init__()\n+        if header_rows is not None:\n+            self.header.header_rows = header_rows\n\n```"}
{"instance_id": "astropy__astropy-14365", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -54,7 +54,7 @@\n \n             # If the line is a READ command, then this is the start of a\n             # data block.\n-            elif line.startswith(\"READ\"):\n+            elif line.upper().startswith(\"READ\"):\n                 if state != \"start\":\n                     warnings.warn(\n                         \"Skipping extra data table\", AstropyWarning, stacklevel=2\n@@ -68,11 +68,11 @@\n                 words = line.split()\n \n                 # The second word should be SERR or TERR\n-                if words[1] == \"SERR\":\n+                if words[1].upper() == \"SERR\":\n                     # Symmetric errors\n                     for i in range(2, len(words)):\n                         err_cols.append(int(words[i]) - 1)\n                     n_cols = len(err_cols) * 2\n-                elif words[1] == \"TERR\":\n+                elif words[1].upper() == \"TERR\":\n                     # Asymmetric errors\n                     raise ValueError(\"TERR not supported\")\n                 else:\n@@ -86,12 +86,12 @@\n \n             # If the line is a NO command, then this is the end of a data\n             # block.\n-            elif line.startswith(\"NO\"):\n+            elif line.upper().startswith(\"NO\"):\n                 if state == \"in_data\":\n                     state = \"end_data\"\n \n             # If the line is a PLOT command, then we can ignore it.\n-            elif line.startswith(\"PLOT\"):\n+            elif line.upper().startswith(\"PLOT\"):\n                 pass\n \n             # Otherwise, it's either a data line or an error\n\n```"}
{"instance_id": "astropy__astropy-14995", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -494,7 +494,7 @@\n \n         # If the operand is an NDData instance but has no mask, the result's\n         # mask is a copy of the self mask.\n-        elif operand is None:\n+        elif operand.mask is None:\n             return deepcopy(self.mask)\n \n         # If both have masks, they are combined.\n\n```"}
{"instance_id": "astropy__astropy-6938", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/io/fits/fitsrec.py\n+++ b/astropy/io/fits/fitsrec.py\n@@ -1112,7 +1112,7 @@\n \n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n         # The TNULL value for ASCII table is a string of blanks.\n         # The regular expression is to avoid replacing valid blanks in a\n\n```"}
{"instance_id": "astropy__astropy-7746", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/astropy/wcs/_wcs.py\n+++ b/astropy/wcs/_wcs.py\n@@ -208,6 +208,17 @@\n         else:\n             raise ValueError(\"pixcrd must be a 1- or 2-D array.\")\n \n+        if nelem == 0:\n+            world = np.empty(shape=(0, self.naxis), dtype=np.double)\n+            imgcrd = np.empty(shape=(0, self.naxis), dtype=np.double)\n+            phi = np.empty(shape=(0), dtype=np.double)\n+            theta = np.empty(shape=(0), dtype=np.double)\n+            stat = np.empty(shape=(0), dtype=np.int)\n+            return {'world': world, 'stat': stat, 'imgcrd': imgcrd,\n+                    'phi': phi, 'theta': theta}\n+\n         world = np.empty((nelem, self.naxis), dtype=np.double)\n         imgcrd = np.empty((nelem, self.naxis), dtype=np.double)\n         phi = np.empty((nelem), dtype=np.double)\n@@ -288,6 +299,17 @@\n         else:\n             raise ValueError(\"world must be a 1- or 2-D array.\")\n \n+        if nelem == 0:\n+            pixcrd = np.empty(shape=(0, self.naxis), dtype=np.double)\n+            imgcrd = np.empty(shape=(0, self.naxis), dtype=np.double)\n+            phi = np.empty(shape=(0), dtype=np.double)\n+            theta = np.empty(shape=(0), dtype=np.double)\n+            stat = np.empty(shape=(0), dtype=np.int)\n+            return {'pixcrd': pixcrd, 'stat': stat, 'imgcrd': imgcrd,\n+                    'phi': phi, 'theta': theta}\n+\n         pixcrd = np.empty((nelem, self.naxis), dtype=np.double)\n         imgcrd = np.empty((nelem, self.naxis), dtype=np.double)\n         phi = np.empty((nelem), dtype=np.double)\n\n```"}
{"instance_id": "django__django-10914", "model_name_or_path": "gemini-2.5-pro", "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -470,7 +470,7 @@\n \n # Default file upload permissions for new files.\n # https://docs.djangoproject.com/en/dev/ref/settings/#file-upload-permissions\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # Default file upload directory permissions for new directories.\n # https://docs.djangoproject.com/en/dev/ref/settings/#file-upload-directory-permissions\ndiff --git a/docs/howto/deployment/checklist.txt b/docs/howto/deployment/checklist.txt\n--- a/docs/howto/deployment/checklist.txt\n+++ b/docs/howto/deployment/checklist.txt\n@@ -101,13 +101,14 @@\n that the permissions of these files are not overly permissive, to prevent a\n malicious user from being able to execute a script that they have uploaded.\n \n-Check the value of your :setting:`FILE_UPLOAD_PERMISSIONS` setting. The default\n-value of ``None`` may result in different permissions depending on the upload\n-handler and the umask of the process. See the\n-:setting:`FILE_UPLOAD_PERMISSIONS` documentation for more details.\n+Check the value of your :setting:`FILE_UPLOAD_PERMISSIONS` setting. The default\n+value of ``0o644`` is reasonable for most use cases. If you want the files to\n+only be readable by the user that the Web server runs as, you could use\n+``0o600``. Files will be saved with these permissions regardless of the\n+process's umask.\n \n-A reasonable value for this setting might be ``0o644`` (or ``0o600`` if you\n-want the files to only be readable by the user that the Web server runs as).\n-Files will be saved with these permissions regardless of the process's umask.\n+If you set this to ``None``, you may get different permissions depending on the\n+upload handler and the umask of the process. See the\n+:setting:`FILE_UPLOAD_PERMISSIONS` documentation for more details.\n \n ``FILE_UPLOAD_DIRECTORY_PERMISSIONS``\n -------------------------------------\ndiff --git a/docs/ref/settings.txt b/docs/ref/settings.txt\n--- a/docs/ref/settings.txt\n+++ b/docs/ref/settings.txt\n@@ -3242,14 +3242,17 @@\n \n .. versionadded:: 1.1\n \n-Default: ``None``\n+Default: ``0o644``\n \n The numeric mode (e.g. ``0o644``) to set newly uploaded files to. For more\n information about what these modes mean, see the documentation for\n :py:func:`os.chmod`.\n \n-If this isn't given or is ``None``, you'll get operating-system dependent\n-behavior. On most platforms, temporary files will have a mode of ``0o600``, and\n-files saved from memory will be saved using the system's standard umask.\n+If this is set to ``None``, Django won't set any permissions on uploaded files,\n+and they will be left with the operating-system dependent permissions. On most\n+platforms, temporary files will have a mode of ``0o600``, and files saved from\n+memory will be saved using the system's standard umask. This can result in\n+inconsistent permissions for files uploaded with different upload handlers.\n \n For security reasons, these permissions are not applied to temporary files that\n Django writes in ``FILE_UPLOAD_TEMP_DIR``.\ndiff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt\nnew file mode 100644\nindex 0000000000..9380217066\n--- /dev/null\n+++ b/docs/releases/3.0.txt\n@@ -0,0 +1,11 @@\n+==================\n+Django 3.0 release notes\n+==================\n+\n+***************************************\n+Backwards incompatible changes in 3.0\n+***************************************\n+\n+Settings\n+========\n+\n+* The default value of the :setting:`FILE_UPLOAD_PERMISSIONS` setting is\n+  changed from ``None`` to ``0o644``. This change provides more consistent\n+  permissions for uploaded files with different upload handlers. To restore\n+  the previous behavior, set ``FILE_UPLOAD_PERMISSIONS`` to ``None``."}
{"instance_id": "django__django-10924", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1099,7 +1099,7 @@\n class FilePathField(ChoiceField):\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path = path\n+        self.path = path() if callable(path) else path\n         self.match = match\n         self.recursive = recursive\n         self.allow_files = allow_files\n\n```"}
{"instance_id": "django__django-11001", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -382,15 +382,25 @@\n             sql, params = self.compile(col)\n             # Don't add the same ordering clause twice.\n-            if self.connection.features.ordering_parts:\n-                without_ordering = self.connection.ops.ordering_parts.search(sql).group(1)\n+            if isinstance(getattr(col, 'expression', None), RawSQL):\n+                if sql in seen:\n+                    continue\n+                seen.add(sql)\n+            elif self.connection.features.ordering_parts:\n+                # search() will return None if the regex doesn't match.\n+                match = self.connection.ops.ordering_parts.search(sql)\n+                if match:\n+                    without_ordering = match.group(1)\n+                else:\n+                    without_ordering = sql\n                 if without_ordering in seen:\n                     continue\n                 seen.add(without_ordering)\n             else:\n                 if sql in seen:\n                     continue\n                 seen.add(sql)\n             result.append((sql, params))\n         return result\n \n\n```"}
{"instance_id": "django__django-11019", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -1,5 +1,6 @@\n \"\"\"\n HTML Widget classes\n \"\"\"\n+import warnings\n from collections import OrderedDict\n \n from django.core.exceptions import MediaOrderConflictWarning\n@@ -14,101 +15,133 @@\n     \"\"\"\n     A class that handles the CSS and JavaScript inclusions for a widget.\n     \"\"\"\n-    _counter = 0\n-\n     def __init__(self, media=None, css=None, js=None):\n         if media:\n-            css = media._css\n-            js = media._js_lists\n+            css = media._css_lists\n+            js = media._js_lists\n         if css is None:\n             css = {}\n+        if isinstance(css, dict):\n+            self._css_lists = [css]\n+        else:\n+            self._css_lists = css\n+\n         if js is None:\n             js = []\n-        self._css = css\n         # self._js_lists can be a list of lists, or a list of strings.\n         # If it's a list of strings, convert to a list of lists.\n         if js and not isinstance(js[0], (list, tuple)):\n-            js = [js]\n-        self._js_lists = js\n+            self._js_lists = [js]\n+        else:\n+            self._js_lists = js\n \n     def __repr__(self):\n         return 'Media(css=%r, js=%r)' % (self.css, self.js)\n \n-    def __str__(self):\n-        return self.render()\n-\n     @property\n     def js(self):\n         return self._js\n \n     @property\n     def _js(self):\n-        if not self._js_lists:\n+        lists = [l for l in self._js_lists if l]\n+        if not lists:\n             return []\n-\n-        # The current implementation of __add__ may produce a list of lists\n-        # that contains some empty lists, so filter them out.\n-        lists = [l for l in self._js_lists if l]\n-        if not lists:\n-            return []\n-\n-        # To provide a consistent merge order, we need to sort the input lists\n-        # by their first item.\n-        lists.sort(key=lambda x: x[0])\n-\n-        # Merge the lists\n-        merged = lists[0]\n-        for lst in lists[1:]:\n-            merged = self.merge(merged, lst)\n-        return merged\n+        return self.merge_lists(lists)\n \n     @property\n     def css(self):\n         return self._css\n \n+    @property\n+    def _css(self):\n+        lists = [d for d in self._css_lists if d]\n+        if not lists:\n+            return {}\n+\n+        # Combine all css lists into a single dictionary.\n+        css = {}\n+        for d in lists:\n+            for medium, sublist in d.items():\n+                if medium not in css:\n+                    css[medium] = []\n+                # sublist can be a list or tuple.\n+                if isinstance(sublist, (list, tuple)):\n+                    css[medium].append(sublist)\n+                else:  # Should be a string.\n+                    css[medium].append([sublist])\n+\n+        for medium, medium_lists in css.items():\n+            css[medium] = self.merge_lists(medium_lists)\n+\n+        return css\n+\n     def __add__(self, other):\n         new_media = Media()\n-        new_media._css = {\n-            **self._css,\n-            **{\n-                medium: self.merge(self.get(medium, []), other.get(medium, []))\n-                for medium, files in other.css.items()\n-            },\n-        }\n+        new_media._css_lists = self._css_lists + other._css_lists\n         new_media._js_lists = self._js_lists + other._js_lists\n         return new_media\n \n-    def merge(self, list1, list2):\n+    def merge_lists(self, lists):\n         \"\"\"\n-        Merge two lists of files, preserving order and removing duplicates.\n+        Merge a list of lists of files, preserving order and removing\n+        duplicates.\n         \"\"\"\n-        if list1 == list2:\n-            return list1\n+        # All items in the order they were first seen.\n+        all_items = []\n+        # A set of all_items for quick lookups.\n+        all_items_set = set()\n+        # A list of lists with no duplicate items.\n+        lists_no_duplicates = []\n+        for sublist in lists:\n+            sublist_no_duplicates = []\n+            for item in sublist:\n+                if item not in all_items_set:\n+                    all_items.append(item)\n+                    all_items_set.add(item)\n+                if item not in sublist_no_duplicates:\n+                    sublist_no_duplicates.append(item)\n+            if sublist_no_duplicates:\n+                lists_no_duplicates.append(sublist_no_duplicates)\n \n-        def is_prefix(list1, list2):\n-            if not list1:\n-                return True\n-            if not list2:\n-                return False\n-            return list1 == list2[:len(list1)]\n+        if not lists_no_duplicates:\n+            return []\n \n-        if is_prefix(list1, list2):\n-            return list2\n-        if is_prefix(list2, list1):\n-            return list1\n+        # A dictionary of dependencies, e.g. dependencies['a'] is a set of\n+        # items that must be included before 'a'.\n+        dependencies = {item: set() for item in all_items}\n+        for sublist in lists_no_duplicates:\n+            for i in range(len(sublist) - 1):\n+                # sublist[i] must come before sublist[i+1].\n+                dependencies[sublist[i + 1]].add(sublist[i])\n \n-        p1 = {x: i for i, x in enumerate(list1)}\n-        p2 = {x: i for i, x in enumerate(list2)}\n-        common = [x for x in list1 if x in p2]\n-        if not common:\n-            return list1 + [x for x in list2 if x not in p1]\n+        # The list of items that have been included in the result.\n+        result = []\n+        result_set = set()\n+        # The list of items that are pending inclusion.\n+        pending = all_items[:]\n+        # A dictionary of each item's index in all_items.\n+        all_items_indices = {item: i for i, item in enumerate(all_items)}\n \n-        for i in range(len(common) - 1):\n-            for j in range(i + 1, len(common)):\n-                x, y = common[i], common[j]\n-                if p1[x] > p1[y] and p2[x] < p2[y]:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (y, x), MediaOrderConflictWarning, stacklevel=2\n-                    )\n-                    break\n-                if p1[x] < p1[y] and p2[x] > p2[y]:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (x, y), MediaOrderConflictWarning, stacklevel=2\n-                    )\n-                    break\n+        while pending:\n+            # Find the next item to include in the result. An item can be\n+            # included if all of its dependencies have been satisfied.\n+            # The order of items in all_items is used to break ties.\n+            best_item = None\n+            for item in pending:\n+                if not (dependencies[item] - result_set):\n+                    best_item = item\n+                    break\n \n-        # The merge logic is to look for a common subsequence. The idea is\n-        # that if list2 contains a subsequence of list1, then we can insert\n-        # the remaining parts of list1 into list2.\n-        merged = self.get_merged_lists_intersection(list1, list2)\n-        p1 = p2 = 0\n-        for item in merged:\n-            if p1 < len(list1) and item == list1[p1]:\n-                p1 += 1\n-            if p2 < len(list2) and item == list2[p2]:\n-                p2 += 1\n-        if p1 < len(list1) or p2 < len(list2):\n-            # There are items in list1 or list2 that don't appear in the\n-            # merged list. This indicates a conflict.\n-            return list1 + [x for x in list2 if x not in list1]\n-        return merged\n+            if best_item is None:\n+                # A dependency cycle was detected.\n+                # Find an item in the pending list that has the fewest\n+                # pending dependencies.\n+                best_item = min(\n+                    pending,\n+                    key=lambda item: (\n+                        len(dependencies[item] - result_set),\n+                        all_items_indices[item],\n+                    )\n+                )\n+                # Find a dependency that creates a cycle.\n+                path = [best_item]\n+                while True:\n+                    # Choose the best dependency to follow. The best one is\n+                    # the one that appears latest in all_items.\n+                    deps = dependencies[path[-1]] & set(pending)\n+                    if not deps:\n+                        break\n+                    dep = max(deps, key=lambda item: all_items_indices[item])\n+                    if dep in path:\n+                        # A cycle is found.\n+                        warnings.warn(\n+                            'Detected media file dependency cycle:\\n' +\n+                            ' -> '.join(path[path.index(dep):] + [dep]),\n+                            MediaOrderConflictWarning, stacklevel=3,\n+                        )\n+                        break\n+                    path.append(dep)\n \n-    def get_merged_lists_intersection(self, list1, list2):\n-        \"\"\"\n-        Return the intersection of two lists of files, preserving order and\n-        removing duplicates.\n-        \"\"\"\n-        p1 = {x: i for i, x in enumerate(list1)}\n-        p2 = {x: i for i, x in enumerate(list2)}\n-        common = [x for x in list1 if x in p2]\n+            result.append(best_item)\n+            result_set.add(best_item)\n+            pending.remove(best_item)\n \n-        for i in range(len(common) - 1):\n-            for j in range(i + 1, len(common)):\n-                x, y = common[i], common[j]\n-                # If x and y are in a different order in list1 and list2,\n-                # there is a conflict.\n-                if (p1[x] > p1[y] and p2[x] < p2[y]) or \\\n-                   (p1[x] < p1[y] and p2[x] > p2[y]):\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (x, y), MediaOrderConflictWarning, stacklevel=2\n-                    )\n-                    # In case of a conflict, we return the naive merge,\n-                    # i.e. list1 followed by unique items from list2.\n-                    return list1 + [x for x in list2 if x not in p1]\n-\n-        # No conflicts found, so we can merge the lists.\n-        # The merged list is the union of the two lists, with the ordering\n-        # of common elements preserved.\n-        merged = []\n-        p1 = p2 = 0\n-        while p1 < len(list1) and p2 < len(list2):\n-            if list1[p1] == list2[p2]:\n-                merged.append(list1[p1])\n-                p1 += 1\n-                p2 += 1\n-            elif list1[p1] in p2:\n-                merged.append(list2[p2])\n-                p2 += 1\n-            else:\n-                merged.append(list1[p1])\n-                p1 += 1\n-        if p1 < len(list1):\n-            merged.extend(list1[p1:])\n-        if p2 < len(list2):\n-            merged.extend(list2[p2:])\n-        return merged\n+        return result\n \n     def render(self):\n         \"\"\"Render the media as a string of HTML.\"\"\"\n\n```"}
{"instance_id": "django__django-11039", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -60,14 +60,14 @@\n                     from_state = executor.loader.project_state((migration.app_label, migration.name), at_end=False)\n                     to_state = executor.loader.project_state((migration.app_label, migration.name), at_end=True)\n                     migration.apply(from_state, schema_editor, backwards=False)\n-                    self.output_transaction = migration.atomic\n+                    self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n                     sql_statements = schema_editor.collected_sql\n             else:\n                 with connection.schema_editor(collect_sql=True, atomic=migration.atomic) as schema_editor:\n                     from_state = executor.loader.project_state((migration.app_label, migration.name), at_end=True)\n                     to_state = executor.loader.project_state((migration.app_label, migration.name), at_end=False)\n                     migration.apply(from_state, schema_editor, backwards=True)\n-                    self.output_transaction = migration.atomic\n+                    self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n                     sql_statements = schema_editor.collected_sql\n             if not sql_statements:\n                 self.stdout.write(\"# Nothing to do for %s.%s\" % (app_label, migration_name), self.style.SQL_KEYWORD)\n\n```"}
{"instance_id": "django__django-11049", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1614,8 +1614,8 @@\n     \"\"\"\n     default_error_messages = {\n         'invalid': _('\u201c%(value)s\u201d value has an invalid format. It must be in '\n-                     '[DD] [HH:[MM:]]ss[.uuuuuu] format.'),\n+                     '[DD] [HH:]MM:ss[.uuuuuu] format.'),\n         'invalid_days': _('\u201c%(value)s\u201d value has an invalid format for days.'),\n         'invalid_time': _('\u201c%(value)s\u201d value has an invalid format for time.'),\n     }\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -630,7 +630,7 @@\n \n class DurationField(Field):\n     default_error_messages = {\n-        'invalid': _('Enter a valid duration.'),\n+        'invalid': _('Enter a valid duration in [DD] [HH:]MM:ss[.uuuuuu] format.'),\n     }\n \n     def to_python(self, value):\n--- a/django/utils/dateparse.py\n+++ b/django/utils/dateparse.py\n@@ -132,8 +132,8 @@\n def parse_duration(value):\n     \"\"\"\n     Parse a duration string and return a datetime.timedelta.\n-    The format is ``[DD] [HH:[MM:]]ss[.uuuuuu]``.\n+    The format is ``[DD] [HH:]MM:ss[.uuuuuu]``.\n     \"\"\"\n     match = duration_re.match(value)\n     if not match:\n\n```"}
{"instance_id": "django__django-11099", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@\n \n @deconstructible\n class ASCIIUsernameValidator:\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -34,7 +34,7 @@\n \n @deconstructible\n class UnicodeUsernameValidator(ASCIIUsernameValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n\n```"}
{"instance_id": "django__django-11133", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -262,8 +262,10 @@\n         # to the client without interpreting it.\n         if isinstance(value, bytes):\n             return value\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         if isinstance(value, str):\n             return value.encode(self.charset)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n\n```"}
{"instance_id": "django__django-11179", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -272,16 +272,18 @@\n                     if not self.can_fast_delete(instance):\n                         break\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n-                    return count, {model._meta.label: count}\n+                    setattr(instance, model._meta.pk.attname, None)\n+                    return count, {model._meta.label: count}\n             else:\n                 # This is the fast-path. If we've reached here, we haven't\n                 # broken out of the loop, so we can be sure that the only\n                 # item in self.data is a single instance of a model with\n                 # no related objects.\n                 for model, instances in self.data.items():\n                     count = sql.DeleteQuery(model).delete_batch(list(instances), self.using)\n-                    return count, {model._meta.label: count}\n+                    for instance in instances:\n+                        setattr(instance, model._meta.pk.attname, None)\n+                    return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n\n```"}
{"instance_id": "django__django-11283", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -28,8 +28,18 @@\n             for action in ('add', 'change', 'delete', 'view')\n         ]\n         proxy_permissions = permissions.filter(codename__in=codenames)\n+        # Find permissions that exist with the proxy content type.\n+        existing_permissions = Permission.objects.filter(\n+            content_type=proxy_content_type,\n+            codename__in=codenames,\n+        ).values_list('codename', flat=True)\n+        # Delete permissions that conflict with existing ones.\n+        proxy_permissions.filter(codename__in=existing_permissions).delete()\n         # Update the permissions to use the proxy content type.\n-        proxy_permissions.update(content_type=proxy_content_type)\n+        proxy_permissions.exclude(\n+            codename__in=existing_permissions,\n+        ).update(content_type=proxy_content_type)\n \n \n def revert_proxy_permissions(apps, schema_editor):\n@@ -55,7 +65,17 @@\n             for action in ('add', 'change', 'delete', 'view')\n         ]\n         proxy_permissions = permissions.filter(codename__in=codenames)\n-        proxy_permissions.update(content_type=concrete_content_type)\n+        # Find permissions that exist with the concrete content type.\n+        existing_permissions = Permission.objects.filter(\n+            content_type=concrete_content_type,\n+            codename__in=codenames,\n+        ).values_list('codename', flat=True)\n+        # Delete permissions that conflict with existing ones.\n+        proxy_permissions.filter(codename__in=existing_permissions).delete()\n+        # Update the permissions to use the concrete content type.\n+        proxy_permissions.exclude(\n+            codename__in=existing_permissions,\n+        ).update(content_type=concrete_content_type)\n \n \n class Migration(migrations.Migration):\n\n```"}
{"instance_id": "django__django-11422", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -200,17 +200,23 @@\n         if module in seen_modules:\n             continue\n         seen_modules.add(module)\n         spec = getattr(module, '__spec__', None)\n-        if spec is None:\n-            # Oy, modules that fail to be findable are a pain.\n-            continue\n-        if not getattr(spec, 'has_location', False):\n-            # These are modules that are not file-based, like built-in\n-            # modules.\n-            continue\n+        origin = None\n+        if spec is None:\n+            # This can happen for __main__ when running a script directly.\n+            if module.__name__ == '__main__':\n+                # The __file__ attribute is not guaranteed to be present.\n+                # It may be missing, for example, in embedded environments.\n+                if hasattr(module, '__file__'):\n+                    origin = module.__file__\n+        elif getattr(spec, 'has_location', False):\n+            origin = spec.origin\n+\n+        if not origin:\n+            continue\n+\n         # For .pyc files, watch the .py file.\n-        origin = Path(spec.origin).resolve()\n+        origin = Path(origin).resolve()\n         if origin in seen_files:\n             continue\n         seen_files.add(origin)\n\n```"}
{"instance_id": "django__django-11564", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -46,11 +46,11 @@\n         super(StaticFilesStorage, self).__init__(location, base_url,\n                                                  *args, **kwargs)\n \n-    def url(self, name):\n+    def url(self, name, request=None):\n         if settings.DEBUG:\n-            return super(StaticFilesStorage, self).url(name)\n+            return super(StaticFilesStorage, self).url(name, request=request)\n         if not self.hashed_name(name):\n             raise ValueError(\"The file '%s' could not be found with %r.\" % (name, self))\n-        return super(StaticFilesStorage, self).url(self.hashed_name(name))\n+        return super(StaticFilesStorage, self).url(self.hashed_name(name), request=request)\n \n     def path(self, name):\n         if not self.hashed_name(name):\n--- a/django/contrib/staticfiles/templatetags/staticfiles.py\n+++ b/django/contrib/staticfiles/templatetags/staticfiles.py\n@@ -36,8 +36,9 @@\n         self.varname = varname\n \n     def url(self, context):\n-        path = self.path.resolve(context)\n-        return staticfiles_storage.url(path)\n+        path = self.path.resolve(context)\n+        request = context.get('request')\n+        return staticfiles_storage.url(path, request=request)\n \n     def render(self, context):\n         url = self.url(context)\n@@ -58,7 +59,8 @@\n         self.varname = varname\n \n     def render(self, context):\n-        prefix = staticfiles_storage.url('')\n+        request = context.get('request')\n+        prefix = staticfiles_storage.url('', request=request)\n         if self.varname is None:\n             return prefix\n         context[self.varname] = prefix\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -3,9 +3,9 @@\n import os\n import re\n try:\n-    from urllib.parse import urljoin\n+    from urllib.parse import urljoin, urlparse\n except ImportError:     # Python 2\n-    from urlparse import urljoin\n+    from urlparse import urljoin, urlparse\n \n from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation\n from django.core.files import File\n@@ -74,7 +74,7 @@\n     def _save(self, name, content):\n         raise NotImplementedError()\n \n-    def url(self, name):\n+    def url(self, name, request=None):\n         \"\"\"\n         Returns an absolute URL where the file's contents can be accessed\n         (via a web browser).\n@@ -110,12 +110,15 @@\n     def delete(self, name):\n         os.remove(name)\n \n-    def url(self, name):\n+    def url(self, name, request=None):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n-        return urljoin(self.base_url, quote(name))\n+        base_url = self.base_url\n+        if request and not urlparse(base_url).scheme:\n+            base_url = request.META.get('SCRIPT_NAME', '') + base_url\n+        return urljoin(base_url, quote(name))\n \n     def _open(self, name, mode='rb'):\n         return File(open(self.path(name), mode))\n \n--- a/django/template/defaulttags.py\n+++ b/django/template/defaulttags.py\n@@ -1,5 +1,6 @@\n from __future__ import unicode_literals\n \n+from django.core.files.storage import default_storage\n from django.template import (Node, Library, TemplateSyntaxError,\n     VariableDoesNotExist, BLOCK_TAG_START, BLOCK_TAG_END,\n     VARIABLE_TAG_START, VARIABLE_TAG_END, SINGLE_BRACE_START,\n@@ -1023,7 +1024,11 @@\n \n class MediaPrefixNode(Node):\n     def render(self, context):\n-        return settings.MEDIA_URL\n+        try:\n+            request = context.get('request')\n+            return default_storage.url('', request=request)\n+        except Exception:\n+            return ''\n \n \n @register.tag\n\n```"}
{"instance_id": "django__django-11583", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -131,12 +131,20 @@\n         if path.suffix in ('.pyc', '.pyo'):\n             path = path.with_suffix('.py')\n         if path.is_file():\n-            results.add(path.resolve().absolute())\n+            try:\n+                results.add(path.resolve().absolute())\n+            except ValueError:\n+                # path.resolve() can raise ValueError on some platforms,\n+                # e.g. on Linux with paths containing null bytes.\n+                pass\n \n     for path in extra_files:\n         if path.is_file():\n-            results.add(path.resolve().absolute())\n+            try:\n+                results.add(path.resolve().absolute())\n+            except ValueError:\n+                # path.resolve() can raise ValueError on some platforms,\n+                # e.g. on Linux with paths containing null bytes.\n+                pass\n \n     return iter(results)\n \n\n```"}
{"instance_id": "django__django-11620", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -483,13 +483,17 @@\n         # Resolve the path. Even with a 404, this should still give us a\n         # resolver match object with a list of patterns tried.\n         resolver = get_resolver(urlconf)\n-        resolver_match = resolver.resolve(request.path_info)\n-    except Resolver404 as e:\n-        # The resolver will raise a Resolver404 if the path is not found.\n-        # In this case, we have no resolver_match object, and we have to\n-        # create one with the patterns that were tried.\n-        resolver_match = e.args[0]\n+        try:\n+            resolver_match = resolver.resolve(request.path_info)\n+        except Http404 as e:\n+            if isinstance(e, Resolver404):\n+                resolver_match = e.args[0]\n+            else:\n+                # A different Http404 was raised.\n+                resolver_match = {}\n     except Exception:\n         # This is unexpected. Let the normal exception handling take over.\n         # See #24833.\n\n```"}
{"instance_id": "django__django-11630", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -1,9 +1,10 @@\n from collections import defaultdict\n from itertools import chain\n \n from django.apps import apps\n+from django.conf import settings\n from django.core.checks import Error, Tags, Warning\n from django.db import models\n from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n from django.utils.inspect import func_supports_parameter\n from django.utils.module_loading import import_string\n@@ -418,15 +419,26 @@\n             continue\n         clashing_models[model._meta.db_table].append(model._meta.label)\n \n+    if settings.DATABASE_ROUTERS:\n+        check = Warning\n+        hint = (\n+            'You have configured multiple database routers. This check is '\n+            'suppressed because it\\'s possible to use the same table name in '\n+            'different databases.'\n+        )\n+    else:\n+        check = Error\n+        hint = None\n+\n     errors = []\n     for table, labels in clashing_models.items():\n         if len(labels) > 1:\n             errors.append(\n-                Error(\n+                check(\n                     \"db_table '%s' is used by multiple models: %s.\" % (\n                         table,\n                         ', '.join(sorted(labels)),\n                     ),\n-                    obj=table,\n+                    hint=hint,\n+                    obj=table,\n                     id='models.E028',\n                 )\n             )\n\n```"}
{"instance_id": "django__django-11742", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -218,6 +218,7 @@\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_max_length_for_choices(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_key(),\n             *self._check_validators(),\n@@ -256,6 +257,38 @@\n                     )\n                 ]\n         return []\n+\n+    def _check_max_length_for_choices(self):\n+        if not hasattr(self, 'max_length') or self.max_length is None or not self.choices:\n+            return []\n+\n+        # Don't perform the check if max_length is not a positive integer,\n+        # as another check will already report the error.\n+        if not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or self.max_length <= 0:\n+            return []\n+\n+        try:\n+            # Catch any error during choices flattening.\n+            flat_choices = self.flatten_choices()\n+        except (TypeError, ValueError):\n+            # Malformed choices will be caught by _check_choices().\n+            return []\n+\n+        if not flat_choices:\n+            return []\n+\n+        max_len = max(len(str(c)) for c, d in flat_choices)\n+        if max_len > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"'max_length' is too small to fit the longest value in \"\n+                    \"'choices' ({} characters).\".format(max_len),\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n \n     def _check_db_index(self, **kwargs):\n         if self.db_index not in (True, False, None):\n\n```"}
{"instance_id": "django__django-11797", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -231,6 +231,8 @@\n         if self.rhs_is_direct_value():\n             return rhs, rhs_params\n         # rhs is a QuerySet.\n-        self.rhs.query.clear_select_clause()\n-        self.rhs.query.add_fields([self.rhs.query.model._meta.pk.name], True)\n+        if not getattr(self.rhs, 'has_select_fields', True):\n+            self.rhs.query.clear_select_clause()\n+            self.rhs.query.add_fields([self.rhs.query.model._meta.pk.name], True)\n         return rhs, rhs_params\n \n \n\n```"}
{"instance_id": "django__django-11815", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -118,8 +118,8 @@\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n+        _, v_imports = serializer_factory(self.value.value).serialize()\n         imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        return '%s.%s[%r]' % (module, enum_class.__name__, self.value.name), imports\n\n```"}
{"instance_id": "django__django-11848", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -1,4 +1,5 @@\n import base64\n+from datetime import datetime\n import re\n import time\n from urllib.parse import (\n@@ -288,12 +289,26 @@\n     Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format\n     \"\"\"\n     # All three formats are supported by time.strptime(), but only if the\n     # right format string is used.\n-    for format in ('%a, %d %b %Y %H:%M:%S GMT',\n-                   '%A, %d-%b-%y %H:%M:%S GMT',\n-                   '%a %b %d %H:%M:%S %Y'):\n-        try:\n-            return int(time.mktime(time.strptime(date, format)))\n-        except (ValueError, TypeError):\n-            continue\n+    rfc850_format = '%A, %d-%b-%y %H:%M:%S GMT'\n+    for format in ('%a, %d %b %Y %H:%M:%S GMT',\n+                   rfc850_format,\n+                   '%a %b %d %H:%M:%S %Y'):\n+        try:\n+            t = time.strptime(date, format)\n+            if format == rfc850_format:\n+                # RFC 850 format can have a two-digit year.\n+                # https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n+                # \"Recipients of a timestamp value in rfc850-date format,\n+                # which uses a two-digit year, MUST interpret a timestamp\n+                # that appears to be more than 50 years in the future as\n+                # representing the most recent year in the past that had\n+                # the same last two digits.\"\n+                year = t.tm_year\n+                if year > datetime.utcnow().year + 50:\n+                    t = t[:0] + (year - 100,) + t[1:]\n+            return int(time.mktime(t))\n+        except (ValueError, TypeError):\n+            continue\n     raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n \n \n\n```"}
{"instance_id": "django__django-11905", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -1,4 +1,7 @@\n+import warnings\n+\n from django.db.models.expressions import Func, Value\n+from django.utils.deprecation import RemovedInDjango40Warning\n \n \n class Lookup:\n@@ -462,12 +465,20 @@ class IsNull(BuiltinLookup):\n     lookup_name = 'isnull'\n     prepare_rhs = False\n \n     def as_sql(self, compiler, connection):\n-        sql, params = compiler.compile(self.lhs)\n-        if self.rhs:\n-            return \"%s IS NULL\" % sql, params\n-        else:\n-            return \"%s IS NOT NULL\" % sql, params\n+        if not isinstance(self.rhs, bool):\n+            warnings.warn(\n+                'Using a non-boolean value for an isnull lookup is '\n+                'deprecated. Use True or False instead.',\n+                RemovedInDjango40Warning,\n+                stacklevel=2,\n+            )\n+        sql, params = compiler.compile(self.lhs)\n+        if self.rhs:\n+            return \"%s IS NULL\" % sql, params\n+        else:\n+            return \"%s IS NOT NULL\" % sql, params\n\n```"}
{"instance_id": "django__django-11910", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -700,6 +700,23 @@\n                 new_field = new_model_state.get_field_by_name(field_name)\n                 # Did the field change?\n                 if old_field.deconstruct() != new_field.deconstruct():\n+                    # If the field is a related field and the relation target\n+                    # has had its primary key renamed, it's not a change we\n+                    # should generate an operation for.\n+                    if (\n+                        new_field.is_relation and new_field.remote_field and\n+                        new_field.remote_field.model and\n+                        hasattr(new_field.remote_field.model, '_meta')\n+                    ):\n+                        remote_app_label = new_field.remote_field.model._meta.app_label\n+                        remote_model_name = new_field.remote_field.model._meta.model_name\n+                        if (remote_app_label, remote_model_name) in from_state.models:\n+                            remote_from_model_state = from_state.models[remote_app_label, remote_model_name]\n+                            if remote_from_model_state.pk:\n+                                pk_name = remote_from_model_state.pk.name\n+                                if (remote_app_label, remote_model_name, pk_name) in self.field_renames:\n+                                    continue\n                     # It's a change, but is it a move?\n                     if self.swappable_first_party(new_field):\n                         # This is a change to a swappable model. We need to\n\n```"}
{"instance_id": "django__django-11964", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -758,7 +758,9 @@\n         return '%s.%s' % (self.model._meta.object_name, self.name)\n \n     def __set__(self, instance, value):\n-        instance.__dict__[self.attname] = value\n+        if isinstance(value, enum.Enum):\n+            value = value.value\n+        instance.__dict__[self.attname] = value\n \n     def __get__(self, instance, cls=None):\n         if instance is None:\n\n```"}
{"instance_id": "django__django-11999", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -756,9 +756,9 @@\n         else:\n             cls._meta.add_field(self, private=True)\n         if self.choices:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                setattr(cls, 'get_%s_display' % self.name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n         if self.column is None:\n             self.column = self.name\n\n```"}
{"instance_id": "django__django-12113", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -10,7 +10,7 @@\n         \"\"\"\n         test_database_name = self.connection.settings_dict['TEST']['NAME']\n         if test_database_name and test_database_name != ':memory:':\n-            return test_database_name\n+            return os.path.abspath(test_database_name)\n         return ':memory:'\n \n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n\n```"}
{"instance_id": "django__django-12125", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -261,7 +261,7 @@\n \n class TypeSerializer(BaseSerializer):\n     def serialize(self):\n-        return self.value.__name__, {\"import %s\" % self.value.__module__}\n+        return self.value.__qualname__, {\"import %s\" % self.value.__module__}\n \n \n class DatetimeSerializer(BaseSerializer):\n\n```"}
{"instance_id": "django__django-12184", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -225,6 +225,11 @@\n             # non-named groups. Otherwise, pass all non-named arguments as\n             # positional arguments.\n             kwargs = match.groupdict()\n+            # For non-nested optional groups, groupdict() returns None for\n+            # the group if it did not match. For nested optional groups,\n+            # groupdict() returns None for the inner group if it did not\n+            # match, but the key for the outer group is missing.\n+            kwargs.update({k: None for k in self.regex.groupindex if k not in kwargs})\n             args = () if kwargs else match.groups()\n             kwargs = {**self.default_args, **kwargs}\n             return ResolverMatch(self.callback, args, kwargs, self.name)\n\n```"}
{"instance_id": "django__django-12284", "model_name_or_path": "gemini-2.5-pro", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -774,7 +774,7 @@\n         if self.choices:\n             # Don't override a get_FOO_display() method defined explicitly on\n             # the model.\n-            if not hasattr(cls, 'get_%s_display' % self.name):\n+            if 'get_%s_display' % self.name not in cls.__dict__:\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,"}
{"instance_id": "django__django-12286", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/checks/translation.py\n+++ b/django/core/checks/translation.py\n@@ -1,5 +1,6 @@\n from django.conf import settings\n+from django.utils.translation import check_for_language\n from django.utils.translation.trans_real import language_code_re\n \n from . import Error, Tags, register\n@@ -44,7 +45,7 @@\n     lang_code = settings.LANGUAGE_CODE\n     if not language_code_re.match(lang_code):\n         errors.append(E001)\n-    if lang_code not in {lang for lang, name in settings.LANGUAGES}:\n+    if not check_for_language(lang_code):\n         errors.append(E004)\n     return errors\n\n```"}
{"instance_id": "django__django-12308", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -101,6 +101,8 @@\n         return formats.number_format(value)\n     elif isinstance(field, (models.IntegerField, models.FloatField)):\n         return formats.number_format(value)\n+    elif field.get_internal_type() == 'JSONField':\n+        return field.get_prep_value(value)\n     elif isinstance(field, ManyToManyField) and value.__class__.__name__ == 'ManyRelatedManager':\n         return ', '.join(map(str, value.all()))\n     else:\n\n```"}
{"instance_id": "django__django-12453", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -4,7 +4,7 @@\n from django.apps import apps\n from django.conf import settings\n from django.core import serializers\n-from django.db import router\n+from django.db import router, transaction\n from django.utils.six import StringIO\n from django.utils.six.moves import input\n \n@@ -125,9 +125,28 @@\n         Reloads the database state from a string generated by\n         the serialize_db_to_string method.\n         \"\"\"\n-        data = StringIO(data)\n-        for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-            obj.save()\n+        data = StringIO(data)\n+        models = set()\n+        objs_with_deferred_fields = []\n+        with transaction.atomic(using=self.connection.alias):\n+            with self.connection.constraint_checks_disabled():\n+                for obj in serializers.deserialize('json', data, using=self.connection.alias):\n+                    obj.save()\n+                    models.add(obj.object.__class__)\n+                    if obj.deferred_fields:\n+                        objs_with_deferred_fields.append(obj)\n+\n+                for obj in objs_with_deferred_fields:\n+                    obj.save_deferred_fields(using=self.connection.alias)\n+\n+            # Since we disabled constraint checks, we must manually check for\n+            # any invalid keys that might have been added.\n+            table_names = [model._meta.db_table for model in models]\n+            try:\n+                self.connection.check_constraints(table_names=table_names)\n+            except Exception as e:\n+                e.args = ('Problem restoring database state: %s' % e,)\n+                raise\n \n     def _get_database_display_str(self, verbosity, database_name):\n         \"\"\"\n\n```"}
{"instance_id": "django__django-12470", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1358,23 +1358,21 @@\n         if field.is_relation and field.related_model:\n             opts = field.related_model._meta\n             if opts.ordering:\n+                ordering_fields = {}\n                 ordering = []\n                 for order in opts.ordering:\n                     if order.startswith(\"-\"):\n                         order_by = order[1:]\n                         order_dir = \"desc\"\n                     else:\n                         order_by = order\n                         order_dir = \"asc\"\n                     if order_by == \"pk\":\n                         order_by = opts.pk.name\n-                    # The returned ordering is a list of field names,\n-                    # not a list of columns.\n-                    if order_dir == \"desc\":\n-                        ordering.append(\"-%s\" % order_by)\n-                    else:\n-                        ordering.append(order_by)\n-                return ordering, {\"\": default_order}, []\n+                    ordering.append(order_by)\n+                    ordering_fields[order_by] = order_dir\n+                return ordering, ordering_fields, []\n             else:\n                 # No ordering on related model, so use its pk.\n-                return [opts.pk.name], {\"\": default_order}, []\n+                return [opts.pk.name], {opts.pk.name: default_order}, []\n \n     def get_select_olists(self):\n         \"\"\"\n\n```"}
{"instance_id": "django__django-12497", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1310,18 +1310,19 @@\n             if len(possible_targets) > 2:\n                 # More than two ForeignKeys to the target model.\n                 # We can't guess which ones to use.\n-                return [\n-                    checks.Error(\n-                        \"The model '%s' has more than two ForeignKeys to model \"\n-                        \"'%s', which is ambiguous and is not permitted. \"\n-                        \"Please specify which two ForeignKeys Django should use \"\n-                        \"via the through_fields keyword argument.\"\n-                        % (self.through._meta.label, self.remote_field.model._meta.label),\n-                        hint=(\n-                            'If you want to create a recursive relationship, '\n-                            'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n-                        ) % (self.remote_field.model._meta.label, self.through._meta.label),\n-                        obj=self,\n-                        id='fields.E335',\n-                    )\n-                ]\n+                error = checks.Error(\n+                    \"The model '%s' has more than two ForeignKeys to model \"\n+                    \"'%s', which is ambiguous and is not permitted. \"\n+                    \"Please specify which two ForeignKeys Django should use \"\n+                    \"via the through_fields keyword argument.\"\n+                    % (self.through._meta.label, self.remote_field.model._meta.label),\n+                    obj=self,\n+                    id='fields.E335',\n+                )\n+                if self.model == self.remote_field.model:\n+                    error.add_note(\n+                        'If this is a recursive relationship, use '\n+                        'ManyToManyField(\"self\", through=\"%s\").' % self.through._meta.label\n+                    )\n+                return [error]\n \n             # There are two ForeignKeys to the target model.\n             # We can't guess which one is the source, and which one is the\n\n```"}
{"instance_id": "django__django-12589", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1937,11 +1937,21 @@\n         self.group_by = []\n         self.extra_select_mask = None\n         if allow_aliases and self.group_by_related:\n+            colliding_columns = None\n             for alias, annotation in self.annotation_select.items():\n                 if alias in self.group_by_related_values:\n-                    self.group_by.extend(annotation.get_group_by_cols())\n+                    original_alias = annotation.alias\n+                    if colliding_columns is None:\n+                        colliding_columns = self.get_colliding_columns()\n+                    if alias in colliding_columns:\n+                        annotation.alias = None\n+                    self.group_by.extend(annotation.get_group_by_cols())\n+                    annotation.alias = original_alias\n             return\n \n         # The logic below is implemented in two steps because of M2M relations.\n         # The first step with group_by_cols is for all \"regular\" fields.\n@@ -2329,6 +2339,22 @@\n         \"\"\"\n         raise NotImplementedError(\"QuerySet cannot be pickled\")\n \n+    def get_colliding_columns(self):\n+        if not hasattr(self, '_colliding_columns_cache'):\n+            # A list of all columns that are part of the query.\n+            colliding_columns = {\n+                f.column for f in self.model._meta.get_fields()\n+                if hasattr(f, 'column')\n+            }\n+            for join in self.alias_map.values():\n+                if join.join_field:\n+                    colliding_columns.update(\n+                        f.column for f in join.join_field.related_model._meta.get_fields()\n+                        if hasattr(f, 'column')\n+                    )\n+            self._colliding_columns_cache = colliding_columns\n+        return self._colliding_columns_cache\n+\n     def get_compiler(self, using=None, connection=None):\n         # Set up the connection object.\n         if using is None and connection is None:\n\n```"}
{"instance_id": "django__django-12700", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -51,5 +51,11 @@\n             # sensitive.\n             pass\n \n-    if isinstance(value, dict):\n-        return {k: cleanse_setting(k, v) for k, v in value.items()}\n-    return value\n+    if isinstance(value, list):\n+        return [cleanse_setting(key, v) for v in value]\n+    elif isinstance(value, tuple):\n+        return tuple(cleanse_setting(key, v) for v in value)\n+    elif isinstance(value, dict):\n+        return {k: cleanse_setting(k, v) for k, v in value.items()}\n+    else:\n+        return value\n\n```"}
{"instance_id": "django__django-12708", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -363,18 +363,28 @@\n         if self.connection.features.supports_index_column_ordering:\n             self.execute(index.remove_sql(model, self))\n         else:\n-            self._delete_composed_index(model, index.fields, {'name': index.name}, self.sql_delete_index)\n+            self._delete_composed_index(\n+                model,\n+                index.fields,\n+                {'name': index.name, 'unique': index.unique},\n+                self.sql_delete_index,\n+            )\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         \"\"\"\n         Delete an index on a set of columns.\n         \"\"\"\n         # Try to find the name of the index\n-        constraint_names = self._constraint_names(model, fields, index=True)\n+        constraint_names = self._constraint_names(\n+            model,\n+            fields,\n+            index=True,\n+            unique=constraint_kwargs.get('unique'),\n+        )\n         if len(constraint_names) == 0:\n             # That's okay, it might not exist\n             return\n         if len(constraint_names) > 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n\n```"}
{"instance_id": "django__django-12747", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -272,8 +272,9 @@\n \n         # fast deletes\n         for qs in self.fast_deletes:\n-            count = qs._raw_delete(using=self.using)\n-            self.rows_count[qs.model._meta.label] = count\n+            count = qs._raw_delete(using=self.using)\n+            if count:\n+                self.rows_count[qs.model._meta.label] = count\n \n         # update fields\n         for model, instances in self.field_updates.items():\n\n```"}
{"instance_id": "django__django-12856", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -23,6 +23,26 @@\n         self.check = check\n         super().__init__(name)\n \n+    def _get_check_fields(self, expression):\n+        if isinstance(expression, F):\n+            yield expression.name\n+        if hasattr(expression, 'get_source_expressions'):\n+            for source in expression.get_source_expressions():\n+                yield from self._get_check_fields(source)\n+        if isinstance(expression, Q):\n+            for child in expression.children:\n+                if isinstance(child, Q):\n+                    yield from self._get_check_fields(child)\n+                else:\n+                    lookup, value = child\n+                    yield lookup.split('__', 1)[0]\n+                    yield from self._get_check_fields(value)\n+\n+    def check(self, model, **kwargs):\n+        errors = super().check(model, **kwargs)\n+        field_names = set(self._get_check_fields(self.check))\n+        errors.extend(model._check_local_fields(list(field_names)))\n+        return errors\n+\n     def __repr__(self):\n         return '<%s: check=%s name=%s>' % (\n             self.__class__.__name__,\n@@ -58,6 +78,11 @@\n         self.condition = condition\n         super().__init__(name)\n \n+    def check(self, model, **kwargs):\n+        errors = super().check(model, **kwargs)\n+        errors.extend(model._check_local_fields(self.fields))\n+        return errors\n+\n     def __repr__(self):\n         return '<%s: fields=%s name=%s>' % (\n             self.__class__.__name__,\n\n```"}
{"instance_id": "django__django-12908", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -21,7 +21,7 @@\n from django.core.exceptions import (\n     FieldError, MultipleObjectsReturned, ObjectDoesNotExist,\n )\n-from django.db import connections, router\n+from django.db import NotSupportedError, connections, router\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.deletion import Collector\n from django.db.models.expressions import Case, F, OuterRef, Value, When\n@@ -1000,6 +1000,11 @@\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\n         \"\"\"\n+        if self.query.combinator:\n+            raise NotSupportedError(\n+                'Calling QuerySet.distinct() after %s() is not supported.'\n+                % self.query.combinator\n+            )\n         if field_names:\n             if not self.query.can_filter():\n                 raise TypeError('Cannot call distinct() with fields on a non-queryset.')\n\n```"}
{"instance_id": "django__django-12915", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/staticfiles/handlers.py\n+++ b/django/contrib/staticfiles/handlers.py\n@@ -15,6 +15,16 @@\n         # If the static file could not be served, fall back to the application.\n         return self.application.get_response(request)\n \n+    async def get_response_async(self, request):\n+        # Try to serve the static file.\n+        if self.file_path(request.path_info):\n+            try:\n+                return self.serve(request)\n+            except Http404:\n+                pass\n+        # If the static file could not be served, fall back to the application.\n+        return await self.application.get_response_async(request)\n+\n     def file_path(self, url):\n         \"\"\"\n         Return the full path to a static file from its URL, if it exists.\n\n```"}
{"instance_id": "django__django-12983", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/utils/text.py\n+++ b/django/utils/text.py\n@@ -415,14 +415,15 @@\n def slugify(value, allow_unicode=False):\n     \"\"\"\n     Convert to ASCII if 'allow_unicode' is False. Convert spaces to hyphens.\n-    Remove characters that aren't alphanumerics, underscores, or hyphens.\n-    Convert to lowercase. Also strip leading and trailing whitespace.\n+    Remove characters that aren't alphanumerics, underscores, or hyphens. Convert\n+    to lowercase. Also strip leading and trailing whitespace, hyphens, and\n+    underscores.\n     \"\"\"\n     value = str(value)\n     if allow_unicode:\n         value = unicodedata.normalize('NFKC', value)\n         value = re.sub(r'[^\\w\\s-]', '', value, flags=re.U).strip().lower()\n-        return re.sub(r'[-\\s]+', '-', value, flags=re.U)\n+        return re.sub(r'[-\\s]+', '-', value, flags=re.U).strip('_-')\n     value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')\n     value = re.sub(r'[^\\w\\s-]', '', value).strip().lower()\n-    return re.sub(r'[-\\s]+', '-', value)\n+    return re.sub(r'[-\\s]+', '-', value).strip('_-')\n\n```"}
{"instance_id": "django__django-13028", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1127,7 +1127,7 @@\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        if hasattr(expression, 'resolve_expression') and not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n\n```"}
{"instance_id": "django__django-13033", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,7 @@ class SQLCompiler:\n             # If we get to this point and the field is a relation to another model,\n             # append the default ordering for that model unless it is the pk\n             # shortcut or the attribute name of the field that is specified.\n-            if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+            if field.is_relation and opts.ordering and getattr(field, 'attname', None) != pieces[-1] and name != 'pk':\n                 # Firstly, avoid infinite loops.\n                 already_seen = already_seen or set()\n                 join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n\n```"}
{"instance_id": "django__django-13158", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -698,6 +698,8 @@\n \n class SQLCombinedCompiler(SQLCompiler):\n     def as_sql(self, with_col_aliases=False, subquery=False):\n+        if not self.query.results:\n+            return super(SQLCombinedCompiler, self).as_sql(with_col_aliases=with_col_aliases, subquery=subquery)\n         result = []\n         params = []\n         combinator = ' %s ' % self.query.combinator\n@@ -715,6 +717,8 @@\n         # The count is the number of rows returned by the full query.\n         # For a combination of queries, we need to wrap the query in a\n         # subquery and count the number of rows returned.\n+        if not self.query.results:\n+            return 0\n         sql, params = self.as_sql()\n         if not sql:\n             return 0\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1220,6 +1220,10 @@\n         # This is calculated by the first query on the list.\n         self.col_count = 0\n \n+    def set_empty(self):\n+        super(CombinedQuery, self).set_empty()\n+        self.results = []\n+\n     def clone(self):\n         clone = super(CombinedQuery, self).clone()\n         clone.results = [r.clone() for r in self.results]\n\n```"}
{"instance_id": "django__django-13220", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -100,6 +100,35 @@\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for key, self_error_list in self.error_dict.items():\n+                other_error_list = other.error_dict[key]\n+                if not self._error_lists_equal(self_error_list, other_error_list):\n+                    return False\n+            return True\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            return False\n+        else:\n+            return self._error_lists_equal(self.error_list, other.error_list)\n+\n+    def _error_lists_equal(self, list1, list2):\n+        if len(list1) != len(list2):\n+            return False\n+        list2_copy = list(list2)\n+        for error1 in list1:\n+            for i, error2 in enumerate(list2_copy):\n+                if (error1.message == error2.message and\n+                        error1.code == error2.code and\n+                        error1.params == error2.params):\n+                    del list2_copy[i]\n+                    break\n+            else:\n+                return False\n+        return True\n+\n     def update_error_dict(self, error_dict):\n         if hasattr(self, 'error_dict'):\n             for field, error_list in self.error_dict.items():\n\n```"}
{"instance_id": "django__django-13230", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/syndication/views.py\n+++ b/django/contrib/syndication/views.py\n@@ -167,6 +167,7 @@\n             author_link = self._get_dynamic_attr(\"item_author_link\", item)\n             pubdate = self._get_dynamic_attr(\"item_pubdate\", item)\n             updateddate = self._get_dynamic_attr(\"item_updateddate\", item)\n+            comments = self._get_dynamic_attr(\"item_comments\", item)\n             extra_kwargs = self._get_dynamic_attr(\"item_extra_kwargs\", item, request)\n \n             feed.add_item(\n@@ -183,6 +184,7 @@\n                 author_name=author_name,\n                 author_email=author_email,\n                 author_link=author_link,\n+                comments=comments,\n                 categories=self._get_dynamic_attr(\"item_categories\", item),\n                 item_copyright=self._get_dynamic_attr(\"item_copyright\", item),\n                 **extra_kwargs,\n\n```"}
{"instance_id": "django__django-13265", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -765,6 +765,37 @@\n         self.optimize_migrations()\n         return self.migrations\n \n+    def _reorder_altered_indexes(self):\n+        \"\"\"\n+        Reorder AddIndex operations to come after AlterOrderWithRespectTo.\n+        \"\"\"\n+        for app_label, ops in self.migrations.items():\n+            i = 0\n+            while i < len(ops):\n+                op = ops[i]\n+                if not isinstance(op, operations.AlterOrderWithRespectTo):\n+                    i += 1\n+                    continue\n+                # Find AddIndex operations on the same model that reference\n+                # _order and move them after this operation.\n+                add_indices_to_move = []\n+                for j, other_op in enumerate(ops):\n+                    if (\n+                        j < i and\n+                        isinstance(other_op, operations.AddIndex) and\n+                        other_op.model_name == op.name and\n+                        '_order' in other_op.index.fields\n+                    ):\n+                        add_indices_to_move.append((j, other_op))\n+                # Reorder AddIndex to come after AlterOrderWithRespectTo.\n+                if add_indices_to_move:\n+                    for j, add_index_op in reversed(add_indices_to_move):\n+                        # Move the AddIndex operation after this\n+                        # AlterOrderWithRespectTo operation.\n+                        ops.insert(i + 1, ops.pop(j))\n+                i += 1\n+\n     def sort_operations(self):\n         \"\"\"\n         Sorts the operations in each migration.\n@@ -783,6 +814,7 @@\n         \"\"\"\n         for app_label in self.migrations:\n             # Do a sort that is stable\n             self.migrations[app_label].sort(key=lambda x: x.stable_sort_key)\n+        self._reorder_altered_indexes()\n \n     def optimize_migrations(self):\n         \"\"\"\n\n```"}
{"instance_id": "django__django-13315", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1,5 +1,6 @@\n from django.core import exceptions\n from django.db import connection, connections, router\n+from django.db.models.aggregates import Count\n from django.db.models.fields import Field, AutoField, PositiveIntegerField\n from django.db.models.query_utils import Q\n from django.db.models import signals\n@@ -861,11 +862,18 @@\n \n     def formfield(self, **kwargs):\n         db = kwargs.pop('using', None)\n-        defaults = {\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.rel.to._default_manager.using(db).complex_filter(self.rel.limit_choices_to),\n-            'to_field_name': self.rel.to_field_name,\n-        }\n+        qs = self.rel.to._default_manager.using(db).complex_filter(self.rel.limit_choices_to)\n+        # The annotate() call is used to force a GROUP BY on the primary key\n+        # of the related model. This is necessary because a join in the\n+        # query can cause duplicate results.\n+        if isinstance(self.rel.limit_choices_to, Q):\n+            qs = qs.annotate(Count(self.rel.to._meta.pk.name))\n+        defaults = {\n+            'form_class': forms.ModelChoiceField,\n+            'queryset': qs,\n+            'to_field_name': self.rel.to_field_name,\n+        }\n         defaults.update(kwargs)\n         return super(ForeignKey, self).formfield(**defaults)\n \n\n```"}
{"instance_id": "django__django-13321", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -123,12 +123,11 @@\n         \"\"\"\n         Decode session data in the pre-Django 1.4 format.\n         \"\"\"\n-        # This is what Django did prior to moving to JSON-based sessions.\n-        encoded_data = base64.b64decode(session_data.encode('ascii'))\n         try:\n+            # This is what Django did prior to moving to JSON-based sessions.\n+            encoded_data = base64.b64decode(session_data.encode('ascii'))\n             # It's simple pickled base64 data - ignore the signature.\n             return pickle.loads(encoded_data)\n         except Exception:\n             # The data could be corrupt.\n             return {}\n\n```"}
{"instance_id": "django__django-13401", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -200,15 +200,19 @@\n     def __eq__(self, other):\n-        # Needed for @total_ordering\n+        # Needed for @total_ordering, but must be different for fields on\n+        # different models.\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            return self.creation_counter == other.creation_counter and self.model == other.model\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n         if isinstance(other, Field):\n-            return self.creation_counter < other.creation_counter\n+            # Order by creation counter first, then by model.\n+            if self.creation_counter != other.creation_counter:\n+                return self.creation_counter < other.creation_counter\n+            return self.model._meta.label_lower < other.model._meta.label_lower\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash(self.creation_counter)\n+        return hash((self.creation_counter, self.model))\n\n```"}
{"instance_id": "django__django-13447", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/admin/sites.py\n+++ b/django/contrib/admin/sites.py\n@@ -236,7 +236,7 @@\n             'admin/app_index.html'\n         ], context)\n \n-    def _build_app_dict(self, request, app_label=None):\n+    def build_app_dict(self, request, app_label=None):\n         \"\"\"\n         Builds the app dictionary. Takes an optional app_label argument to filter\n         the resulting list of apps.\n@@ -257,6 +257,7 @@\n                         'name': capfirst(model._meta.verbose_name_plural),\n                         'object_name': model._meta.object_name,\n                         'perms': perms,\n+                        'model': model,\n                     }\n                     if model_admin.has_add_permission(request):\n                         model_dict['add_url'] = reverse('admin:%s_%s_add' % info, current_app=self.name)\n@@ -287,7 +288,7 @@\n         Displays the main admin index page, which lists all of the apps that have\n         been registered in this site.\n         \"\"\"\n-        app_dict = self._build_app_dict(request)\n+        app_dict = self.build_app_dict(request)\n \n         # Sort the apps alphabetically.\n         app_list = sorted(app_dict.values(), key=lambda x: x['name'].lower())\n@@ -314,7 +315,7 @@\n         Displays the model list page for a given app.\n         \"\"\"\n         app_config = apps.get_app_config(app_label)\n-        app_dict = self._build_app_dict(request, app_label)\n+        app_dict = self.build_app_dict(request, app_label)\n         if not app_dict:\n             raise Http404('The requested admin page does not exist.')\n         # Sort the models alphabetically within each app.\n\n```"}
{"instance_id": "django__django-13448", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -2,8 +2,10 @@\n import time\n \n from django.core.management import call_command\n from django.db import connections\n from django.utils.functional import cached_property\n+from django.apps import apps\n+from django.conf import settings\n \n \n class BaseDatabaseCreation:\n@@ -78,7 +80,25 @@\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # The database will be created from scratch, without running\n+            # migrations.\n+            try:\n+                old_migration_modules = settings.MIGRATION_MODULES\n+                settings.MIGRATION_MODULES = {\n+                    app.label: None\n+                    for app in apps.get_app_configs()\n+                }\n+                call_command(\n+                    'migrate',\n+                    verbosity=max(verbosity - 1, 0),\n+                    interactive=False,\n+                    database=self.connection.alias,\n+                    run_syncdb=True,\n+                )\n+            finally:\n+                settings.MIGRATION_MODULES = old_migration_modules\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is\n\n```"}
{"instance_id": "django__django-13551", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -267,6 +267,12 @@\n         \"\"\"\n         return True\n \n+    def get_email_field_name(self):\n+        try:\n+            return self.EMAIL_FIELD\n+        except AttributeError:\n+            return 'email'\n+\n     def set_password(self, raw_password):\n         self.password = make_password(raw_password)\n \n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -119,10 +119,15 @@\n             password_salt = ''\n         else:\n             password_salt = password.split('$')[1]\n+        # Ensure that the token is invalidated when the user's email address\n+        # changes.\n+        email_field_name = user.get_email_field_name()\n+        email = getattr(user, email_field_name, '') or ''\n         return (\n             six.text_type(user.pk) + password_salt +\n-            six.text_type(timestamp)\n+            six.text_type(timestamp) + six.text_type(email)\n         )\n \n     def _num_seconds(self, dt):\n\n```"}
{"instance_id": "django__django-13590", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1379,7 +1379,7 @@\n                 self.resolve_lookup_value(v, can_reuse, allow_joins)\n                 for v in value\n             )\n-            value = type(value)(resolved_lookups)\n+            value = type(value)(*resolved_lookups)\n         return value\n \n     def solve_lookup_type(self, lookup):\n\n```"}
{"instance_id": "django__django-13658", "model_name_or_path": "gemini-2.5-pro", "model_patch": "", "error": "The model response did not complete successfully.\nFinish reason: 2.\nFinish message: .\nSafety ratings: [].\nTo protect the integrity of the chat session, the request and response were not added to chat history.\nTo skip the response validation, specify `model.start_chat(response_validation=False)`.\nNote that letting blocked or otherwise incomplete responses into chat history might lead to future interactions being blocked by the service."}
{"instance_id": "django__django-13660", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,12 +81,12 @@\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n\n```"}
{"instance_id": "django__django-13710", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -26,7 +26,7 @@\n from django.template.response import SimpleTemplateResponse, TemplateResponse\n from django.urls import reverse\n from django.utils.decorators import method_decorator\n-from django.utils.text import capfirst, get_text_list\n+from django.utils.text import capfirst, format_lazy, get_text_list\n from django.utils.translation import gettext as _, ngettext\n from django.views.decorators.csrf import csrf_protect\n \n@@ -1613,10 +1613,13 @@\n         self.parent_model = parent_model\n         self.opts = self.model._meta\n         super().__init__()\n-        if self.verbose_name is None:\n-            self.verbose_name = self.model._meta.verbose_name\n-        if self.verbose_name_plural is None:\n-            self.verbose_name_plural = self.model._meta.verbose_name_plural\n+        if self.verbose_name_plural is None:\n+            if self.verbose_name:\n+                self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n+            else:\n+                self.verbose_name_plural = self.model._meta.verbose_name_plural\n+        if self.verbose_name is None:\n+            self.verbose_name = self.model._meta.verbose_name\n \n     def get_formset(self, request, obj=None, **kwargs):\n         \"\"\"Return a BaseInlineFormSet class for use in admin add/change views.\"\"\"\n\n```"}
{"instance_id": "django__django-13757", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -302,8 +302,29 @@\n     pass\n \n \n+class KeyTransformIsNull(IsNull):\n+    def as_oracle(self, compiler, connection):\n+        lhs, params = compiler.compile(self.lhs.lhs)\n+        key_name = self.lhs.key_name\n+        if self.rhs:\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), params\n+        return \"JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), params\n+\n+    def as_sqlite(self, compiler, connection):\n+        # SQLite < 3.38.0 doesn't support JSON_TYPE().\n+        if connection.Database.sqlite_version_info < (3, 38):\n+            return super().as_sql(compiler, connection)\n+        lhs, params = compiler.compile(self.lhs.lhs)\n+        key_name = self.lhs.key_name\n+        if self.rhs:\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), params\n+        return \"JSON_TYPE(%s, '$.%s') IS NOT NULL\" % (lhs, key_name), params\n+\n+\n KeyTransform.register_lookup(KeyTransformTextExact)\n KeyTransform.register_lookup(KeyTransformIContains)\n-KeyTransform.register_lookup(IsNull)\n+KeyTransform.register_lookup(KeyTransformIsNull)\n \n \n class JSONField(Field):\n\n```"}
{"instance_id": "django__django-13768", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/dispatch/dispatcher.py\n+++ b/django/dispatch/dispatcher.py\n@@ -1,10 +1,14 @@\n+import logging\n from weakref import WeakKeyDictionary\n \n from django.utils.inspect import func_supports_parameter\n \n # A marker for caching\n NO_RECEIVERS = object()\n \n+logger = logging.getLogger(__name__)\n+\n \n class Signal:\n     \"\"\"\n@@ -241,6 +245,7 @@\n             try:\n                 response = receiver(signal=self, sender=sender, **named)\n             except Exception as err:\n+                logger.exception('Error in receiver %r', receiver)\n                 responses.append((receiver, err))\n             else:\n                 responses.append((receiver, response))\n\n```"}
{"instance_id": "django__django-13925", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/checks.py\n+++ b/django/db/models/checks.py\n@@ -25,7 +25,7 @@\n     errors = []\n     for model in apps.get_models():\n         if not model._meta.abstract and not model._meta.proxy and not model._meta.swapped:\n-            if not model._meta.pk and not model._meta.parents:\n+            if not model._meta.pk and not model._meta.local_parents:\n                 # If there's no primary key and this isn't a child model,\n                 # complain.\n                 errors.append(\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -102,6 +102,7 @@\n         self.proxy_for_model = None\n         self.verbose_name = None\n         self.verbose_name_plural = None\n+        self.local_parents = []\n \n         # Lists of fields attached to this model.\n         # Do not modify these directly, use the public API instead.\n@@ -403,6 +404,7 @@\n             if not issubclass(base, models.Model) or base._meta.abstract:\n                 continue\n             # The new model is a child of `base`.\n+            self.local_parents.append(base)\n             if base in base_meta.parents:\n                 # `base` is a child of another model.\n                 self.parents.update(base_meta.parents)\n\n```"}
{"instance_id": "django__django-13933", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1155,8 +1155,8 @@\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n-        'invalid_choice': _('Select a valid choice. That choice is not one of'\n-                            ' the available choices.'),\n+        'invalid_choice': _('Select a valid choice. %(value)s is not one of the'\n+                            ' available choices.'),\n     }\n     iterator = ModelChoiceIterator\n \n@@ -1215,7 +1215,11 @@\n             key = self.to_field_name or 'pk'\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(\n+                self.error_messages['invalid_choice'],\n+                code='invalid_choice',\n+                params={'value': value},\n+            )\n         return value\n \n     def valid_value(self, value):\n\n```"}
{"instance_id": "django__django-13964", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -933,7 +933,7 @@ class Model(metaclass=ModelBase):\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, field.name)\n                     )\n-                elif obj is not None and getattr(self, field.attname) is None:\n+                elif obj is not None and getattr(self, field.attname) in field.related_field.empty_values:\n                     # Use pk from related object if it has been saved after\n                     # an assignment.\n                     setattr(self, field.attname, obj.pk)\n\n```"}
{"instance_id": "django__django-14016", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -24,7 +24,13 @@\n         \"\"\"\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # The children are either Q objects or (key, value) tuples.\n+        # We need to deepcopy Q objects and shallow copy the tuples.\n+        obj.children = []\n+        for child in self.children:\n+            if isinstance(child, Q):\n+                obj.children.append(copy.deepcopy(child, memodict))\n+            else:\n+                obj.children.append(child)\n         return obj\n \n     def _combine(self, other, conn):\n\n```"}
{"instance_id": "django__django-14017", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -64,9 +64,13 @@\n                          connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+        if not isinstance(other, Q):\n+            from django.db.models.expressions import Combinable, CombinedExpression\n+            if isinstance(other, Combinable):\n+                return CombinedExpression(self, conn, other)\n+            raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n             return self\n\n```"}
{"instance_id": "django__django-14155", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/urls/resolver.py\n+++ b/django/urls/resolver.py\n@@ -1,4 +1,5 @@\n-from importlib import import_module\n+import functools\n+from importlib import import_module\n \n from django.core.exceptions import ImproperlyConfigured\n from django.utils.functional import cached_property\n@@ -148,12 +149,19 @@\n \n \n class ResolverMatch:\n-    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n-        self.func = func\n-        self.args = args\n-        self.kwargs = kwargs\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        if isinstance(func, functools.partial):\n+            self.func = func.func\n+            self.args = func.args + args\n+            self.kwargs = func.keywords.copy()\n+            self.kwargs.update(kwargs)\n+        else:\n+            self.func = func\n+            self.args = args\n+            self.kwargs = kwargs\n+\n         self.url_name = url_name\n         self.route = route\n         self.tried = tried\n \n         # Sane defaults for attributes that may not be present.\n\n```"}
{"instance_id": "django__django-14238", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -165,10 +165,11 @@\n \n     def __init__(cls, name, bases, attrs):\n         super().__init__(name, bases, attrs)\n-        if not cls.__module__.startswith(\"django.db.models.fields\"):\n-            return\n-        if name in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+        if any(b in cls._subclasses for b in bases):\n+            cls._subclasses.add(cls)\n+        elif cls.__module__.startswith(\"django.db.models.fields\") and name in (\n+            \"AutoField\", \"BigAutoField\", \"SmallAutoField\",\n+        ):\n             cls._subclasses.add(cls)\n \n     def __subclasscheck__(cls, subclass):\n\n```"}
{"instance_id": "django__django-14382", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/management/templates.py\n+++ b/django/core/management/templates.py\n@@ -74,7 +74,7 @@\n             # The 'app' template must be rendered in a directory named after the\n             # app.\n             if target:\n-                self.validate_name(os.path.basename(target), 'directory')\n+                self.validate_name(os.path.basename(target.rstrip(os.sep)), 'directory')\n             else:\n                 self.validate_name(name, 'name')\n \n\n```"}
{"instance_id": "django__django-14411", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/contrib/auth/widgets.py\n+++ b/django/contrib/auth/widgets.py\n@@ -7,5 +7,8 @@\n     def render(self, name, value, attrs=None):\n         return mark_safe(value) if value else _(\"Not set\")\n \n+    def id_for_label(self, id_):\n+        return None\n+\n     def _has_changed(self, initial, data):\n         return False\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -57,7 +57,9 @@\n         id_ = widget.attrs.get('id') or self.auto_id\n         if id_:\n             attrs = attrs.copy() if attrs else {}\n-            attrs['for'] = widget.id_for_label(id_)\n+            id_for_label = widget.id_for_label(id_)\n+            if id_for_label:\n+                attrs['for'] = id_for_label\n         attrs = flatatt(attrs)\n         contents = force_text(contents)\n         return format_html('<label{0}>{1}</label>', attrs, contents)\n\n```"}
{"instance_id": "django__django-14534", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -247,10 +247,9 @@\n     def id_for_label(self):\n         \"\"\"\n-        Return the ID of this widget, which is used for the <label> 'for' attribute.\n+        Return the ID of this widget, which is used for the <label> 'for'\n+        attribute.\n         \"\"\"\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+        return self.data['attrs'].get('id')\n \n     def render(self, template_name=None, context=None, renderer=None):\n         \"\"\"\n\n```"}
