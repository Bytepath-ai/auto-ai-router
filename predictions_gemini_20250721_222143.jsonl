{"instance_id": "django__django-11039", "model_name_or_path": "gemini-2.5-pro", "model_patch": "```diff\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -37,7 +37,7 @@\n         # Make a fake schema editor\n         editor = connection.schema_editor(atomic=migration.atomic, collect_sql=True)\n         # Are we wrapping this migration in a transaction?\n-        self.output_transaction = migration.atomic\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n         # Show begin transaction if needed\n         if self.output_transaction:\n             self.stdout.write(\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -289,6 +289,18 @@\n         out = io.StringIO()\n         call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n         self.assertNotIn(self.get_begin_sql(), out.getvalue())\n+\n+    def test_sqlmigrate_for_unsupported_transactional_ddl_db(self):\n+        \"\"\"\n+        sqlmigrate doesn't wrap migrations in a transaction on databases that\n+        don't support transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch('django.db.connection.features.can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        output = out.getvalue()\n+        self.assertNotIn(self.get_begin_sql(), output)\n+        self.assertNotIn(connection.ops.end_transaction_sql(), output)\n \n     @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_empty\"})\n     def test_sqlmigrate_empty_migration(self):\n\n```"}
