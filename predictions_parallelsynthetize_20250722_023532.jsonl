{"instance_id": "astropy__astropy-12907", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -52,7 +52,14 @@\n                                n_in_left + n_in_right), dtype=bool)\n \n             matrix[:n_out_left, :n_in_left] = left\n-            matrix[n_out_left:, n_in_left:] = np.any(right, axis=1, keepdims=True)\n+            # For '&' the outputs of each side depend *only* on the inputs\n+            # belonging to that side.  We therefore embed each side's full\n+            # separability matrix into the appropriate quadrant of the\n+            # combined matrix, *not* just a reduction of that matrix.\n+            #\n+            # embed right side \u2013 note the column/row offsets\n+            matrix[n_out_left:, n_in_left:] = right\n \n         elif model.op in (models._ADD, '+', models._OR, '|'):\n             # The outputs of both the left and right depend on all inputs.\n\n```"}
{"instance_id": "astropy__astropy-14182", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -6,39 +6,36 @@\n     RST table writer\n     \"\"\"\n \n-    def __init__(self, delimiter=None, booktabs=False):\n+    def __init__(self, delimiter=None, booktabs=False, header_rows=None):\n         super().__init__(delimiter=delimiter)\n         self.booktabs = booktabs\n+        self.header.header_rows = header_rows\n \n     def write(self, table, output):\n         self.data.header.col_widths = self.header.get_col_widths(table)\n         lines = self.header.write(table)\n+        num_header_lines = len(lines)\n         lines.extend(self.data.write(table.columns.values()))\n         if not self.booktabs:\n-            lines = _add_rst_header_line(lines, \"=\")\n+            lines = _add_rst_header_line(lines, \"=\", num_header_lines)\n         else:\n             lines = _add_booktabs_header_line(lines)\n         output.write(\"\\n\".join(lines))\n         output.write(\"\\n\")\n \n \n-def _add_rst_header_line(lines, char):\n+def _add_rst_header_line(lines, char, num_header_lines=1):\n     \"\"\"Add a restructuredtext header line to the top and bottom of ``lines``\"\"\"\n-    lines = _add_divider(lines, char)\n-    lines.insert(0, lines[len(lines) - 1])\n-    return lines\n-\n-\n-def _add_divider(lines, char):\n-    \"\"\"Add a divider line to ``lines``\"\"\"\n     if not lines:\n         return lines\n+\n+    # Create the separator line based on the first header line\n     divider = list(lines[0])\n     for i, c in enumerate(lines[0]):\n         if c != \" \":\n             divider[i] = char\n-    lines.insert(1, \"\".join(divider))\n+    divider_line = \"\".join(divider)\n+\n+    lines.insert(0, divider_line)\n+    lines.insert(num_header_lines + 1, divider_line)\n+    lines.append(divider_line)\n     return lines\n \n \n\n```"}
{"instance_id": "astropy__astropy-14365", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -68,7 +68,7 @@\n         _new_re = rf\"NO({sep}NO)+\"\n         _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n         _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-        _line_type_re = re.compile(_type_re)\n+        _line_type_re = re.compile(_type_re, re.IGNORECASE)\n         _line_type.cache[delimiter] = _line_type_re\n     match = _line_type_re.match(line)\n     if match is None:\n\n```"}
{"instance_id": "astropy__astropy-14995", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -495,7 +495,7 @@\n         elif self.mask is None and operand is not None:\n             # self.mask is None and operand.mask may or may not be None\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand.mask is None:\n             return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n\n```"}
{"instance_id": "astropy__astropy-6938", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py\n--- a/astropy/io/fits/fitsrec.py\n+++ b/astropy/io/fits/fitsrec.py\n@@ -1331,7 +1331,7 @@ class FITS_rec(np.recarray):\n         output_field = np.char.array(field, itemsize=itemsize)\n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n         # pad the field using whitespace from the right\n         l = output_field.itemsize\n\n```"}
{"instance_id": "astropy__astropy-7746", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1290,6 +1290,13 @@\n                 def _return_single_array(xy, origin):\n                     \"\"\"\n                     The case where the input is a single array.\n+                    \"\"\"\n+\n+                    # Short-circuit for empty arrays\n+                    if xy.shape[0] == 0:\n+                        if sky == 'output':\n+                            return np.empty((0, self.wcs.naxis), dtype=float)\n+                        return np.empty((0, self.naxis), dtype=float)\n+\n+                    if ra_dec_order and sky == 'input':\n+                        xy = self._denormalize_sky(xy)\n+                    output = func(xy, origin)\n+@@ -1303,6 +1310,13 @@\n                 def _return_list_of_arrays(axes, origin):\n                     \"\"\"\n                     The case where the input is a list of arrays.\n+                    \"\"\"\n+\n+                    # Short-circuit for empty arrays\n+                    if len(axes[0]) == 0:\n+                        if sky == 'output':\n+                            return [np.array([], dtype=float) for i in range(self.wcs.naxis)]\n+                        return [np.array([], dtype=float) for i in range(self.naxis)]\n+\n+                    # The following converts a list of arrays into a single\n+                    # 2-D array for use with the underlying wcslib library.\n+                    xy = np.vstack(axes).transpose()\n\n```"}
{"instance_id": "django__django-10914", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,7 @@\n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n # https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\n--- a/django/core/checks/security/base.py\n+++ b/django/core/checks/security/base.py\n@@ -141,19 +141,6 @@\n     )\n \n \n-W022 = SecurityWarning(\n-    'You have not set the FILE_UPLOAD_PERMISSIONS setting. Your uploaded '\n-    'files will have inconsistent permissions.',\n-    id='security.W022',\n-)\n-\n-\n @register(Tags.security, deploy=True)\n def check_security_issue_30296(app_configs, **kwargs):\n     if not settings.is_overridden('SECURE_REFERRER_POLICY'):\n@@ -181,10 +168,3 @@\n     if not settings.SECURE_HSTS_PRELOAD:\n         return [W021]\n     return []\n-\n-\n-@register(Tags.security, deploy=True)\n-def check_file_upload_permissions(app_configs, **kwargs):\n-    if settings.is_overridden('FILE_UPLOAD_PERMISSIONS'):\n-        return []\n-    return [W022]\n--- a/docs/howto/deployment/checklist.txt\n+++ b/docs/howto/deployment/checklist.txt\n@@ -157,12 +157,21 @@\n :setting:`FILE_UPLOAD_PERMISSIONS`\n ----------------------------------\n \n-With the default file upload settings, files smaller than\n-:setting:`FILE_UPLOAD_MAX_MEMORY_SIZE` may be stored with a different mode\n-than larger files as described in :setting:`FILE_UPLOAD_PERMISSIONS`.\n+If your file upload settings allow for local file system storage, you should\n+ensure that the permissions of these files are appropriate for your use case. By\n+default, :setting:`FILE_UPLOAD_PERMISSIONS` is ``0o644``.\n \n-Setting :setting:`FILE_UPLOAD_PERMISSIONS` ensures all files are uploaded with\n-the same permissions.\n+With Django's default upload handlers, the permissions of uploaded files can be\n+inconsistent if :setting:`FILE_UPLOAD_PERMISSIONS` is set to ``None``:\n+\n+*   Uploaded files smaller than :setting:`FILE_UPLOAD_MAX_MEMORY_SIZE` are\n+    stored in memory and then saved to disk. The permissions of the saved\n+    files are governed by your system's ``umask``.\n+*   Uploaded files larger than :setting:`FILE_UPLOAD_MAX_MEMORY_SIZE` are\n+    streamed to a temporary file on disk. On a POSIX system, this temporary\n+    file may have permissions of ``0o600``. This file is then moved to its\n+    final destination, transferring these permissions with it.\n \n HTTPS\n =====\n--- a/docs/ref/checks.txt\n+++ b/docs/ref/checks.txt\n@@ -176,9 +176,6 @@\n * **security.W021**: You have not set the\n   :setting:`SECURE_HSTS_PRELOAD` setting to ``True``. Without this, your site\n   cannot be submitted to the browser preload list.\n-* **security.W022**: You have not set the :setting:`FILE_UPLOAD_PERMISSIONS`\n-  setting. Your uploaded files will have inconsistent permissions.\n \n Signals\n -------\n--- a/docs/ref/settings.txt\n+++ b/docs/ref/settings.txt\n@@ -1349,29 +1349,22 @@\n FILE_UPLOAD_PERMISSIONS\n -----------------------\n \n-Default: ``None``\n+Default: ``0o644``\n \n-The numeric mode (i.e. ``0o644``) to set newly uploaded files to. For\n+The numeric mode to set newly uploaded files to. For\n more information about what these modes mean, see the documentation for\n :func:`os.chmod`.\n \n-If this isn't given or is ``None``, you'll get operating-system dependent\n-behavior. On most platforms, temporary files will have a mode of ``0o600``,\n-and files saved from memory will be saved using the system's standard umask.\n+If this is set to ``None``, you'll get operating-system dependent behavior.\n+With Django's default upload handlers, this can result in inconsistent\n+permissions for uploaded files. Small files handled by\n+``MemoryFileUploadHandler`` have permissions determined by your process's\n+umask. Large files handled by ``TemporaryFileUploadHandler`` may have\n+permissions set by your platform's temporary file implementation (e.g. ``0o600``\n+on many Unix-like systems).\n \n-.. warning::\n+.. versionchanged:: 3.0\n \n-    In older versions of Django, if :setting:`FILE_UPLOAD_PERMISSIONS` is\n-    ``None``, you'll get inconsistent behavior. In this case, if an uploaded\n-    file is smaller than :setting:`FILE_UPLOAD_MAX_MEMORY_SIZE`, it will have\n-    the permissions set by the `umask`_ (e.g. ``0o666``). If an uploaded file\n-    is larger than :setting:`FILE_UPLOAD_MAX_MEMORY_SIZE`, it will have the\n-    permissions ``0o600``. See :ref:`file-upload-security` for details.\n-\n-    For security reasons, these permissions aren't applied to the temporary\n-    files that are stored in :setting:`FILE_UPLOAD_TEMP_DIR`. It would\n-    always be preferable to specify it explicitly.\n+    The default value was changed from ``None`` to ``0o644``. To revert to the\n+    previous behavior, set ``FILE_UPLOAD_PERMISSIONS`` to ``None``.\n \n-.. _umask: https://en.wikipedia.org/wiki/Umask\n+For security reasons, these permissions aren't applied to the temporary files\n+that are stored in :setting:`FILE_UPLOAD_TEMP_DIR`.\n--- a/docs/releases/3.0.txt\n+++ b/docs/releases/3.0.txt\n@@ -8,6 +8,16 @@\n Backwards incompatible changes in 3.0\n =====================================\n \n+* The default value of the :setting:`FILE_UPLOAD_PERMISSIONS` setting is now\n+  ``0o644``. Previously it was ``None``, which resulted in file permissions\n+  that depended on the file upload handler used and the system's umask.\n+  On some platforms, this could lead to inconsistent permissions for files\n+  uploaded with ``MemoryFileUploadHandler`` (small files) versus\n+  ``TemporaryFileUploadHandler`` (large files). For example, large files\n+  might be saved with ``0o600`` permissions. Explicitly setting\n+  :setting:`FILE_UPLOAD_PERMISSIONS` is recommended for consistent behavior.\n+  To restore the previous behavior, set ``FILE_UPLOAD_PERMISSIONS = None``.\n+\n * The undocumented ``--skip-checks`` option for management commands is removed.\n   :option:`--skip-checks <django-admin --skip-checks>` should be used instead.\n   The ability to pass ``skip_checks=True`` to ``call_command()`` is also\n--- a/tests/file_uploads/tests.py\n+++ b/tests/file_uploads/tests.py\n@@ -149,16 +149,30 @@\n         if hasattr(os, 'stat'):\n             # This doesn't work on Windows.\n             stat = os.stat(os.path.join(self.test_dirname, 'temp_upload.txt'))\n-            # The file is created using TemporaryFileUploadHandler, which should\n-            # result in 0o600 permissions on POSIX.\n-            self.assertEqual(stat.st_mode & 0o777, 0o600)\n+            # The file is created using TemporaryFileUploadHandler, but\n+            # FILE_UPLOAD_PERMISSIONS is used to ensure consistent permissions.\n+            self.assertEqual(stat.st_mode & 0o777, 0o644)\n \n     def test_broken_handler(self):\n         self.upload_file(b'a' * 1024, self.broken_handler)\n         self.assertFileContains(b'a' * 1024)\n \n+    @override_settings(FILE_UPLOAD_PERMISSIONS=None)\n+    def test_large_upload_permissions_none(self):\n+        \"\"\"\n+        With FILE_UPLOAD_PERMISSIONS=None, a large file uploaded with\n+        TemporaryFileUploadHandler has permissions determined by the system's\n+        temporary file implementation.\n+        \"\"\"\n+        payload = b'b' * (settings.FILE_UPLOAD_MAX_MEMORY_SIZE + 1)\n+        self.upload_file(payload)\n+        if hasattr(os, 'stat'):\n+            stat = os.stat(os.path.join(self.test_dirname, 'temp_upload.txt'))\n+            # The file is created using TemporaryFileUploadHandler, which\n+            # should result in 0o600 permissions on POSIX.\n+            self.assertEqual(stat.st_mode & 0o777, 0o600)\n+\n \n class DirectoryCreationTests(SimpleTestCase):\n     storage = FileSystemStorage()\n\n```"}
{"instance_id": "django__django-10924", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1728,6 +1728,11 @@ class FilePathField(Field):\n         errors.extend(self._check_path())\n         return errors\n \n     def _check_path(self):\n+        if callable(self.path):\n+            # Don't run checks for callables, as the path can't be resolved\n+            # at this point.\n+            return []\n         if self.path == '':\n             return [\n                 checks.Error(\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1089,9 +1089,11 @@ class FilePathField(ChoiceField):\n     def __init__(self, path, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        if callable(path):\n+            path = path()\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n         choices = []\n\n```"}
{"instance_id": "django__django-11001", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -108,7 +108,10 @@\n         get_order_by_default,\n         get_order_by_primary_key,\n     ]\n-    ordering_parts = re.compile(r'(.*)\\s+(?:ASC|DESC)$', re.IGNORECASE)\n+    # Use DOTALL so that the pattern also matches across newlines. This prevents\n+    # multiline SQL fragments (e.g. RawSQL expressions split over several\n+    # lines) from being truncated to only their last line.\n+    ordering_parts = re.compile(r'(.*)\\s+(?:ASC|DESC)$', re.IGNORECASE | re.DOTALL)\n \n     def __init__(self, query, connection, using):\n         self.query = query\n\n```"}
{"instance_id": "django__django-11019", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -1,6 +1,7 @@\n import copy\n import datetime\n import warnings\n+from collections import OrderedDict, defaultdict\n from itertools import chain\n \n from django.conf import settings\n@@ -48,69 +49,74 @@\n                     # For backwards-compatibility, handle paths not wrapped in a\n                     # list.\n                     self._js_lists.append([path])\n-        self._dependencies = defaultdict(set)\n-\n-    def __str__(self):\n-        return self.render()\n \n     def __repr__(self):\n         return 'Media(css=%r, js=%r)' % (self.css, self.js)\n \n-    def __add__(self, other):\n+    def __add__(self, other):\n         new = Media()\n         new._css_lists = self._css_lists + other._css_lists\n         new._js_lists = self._js_lists + other._js_lists\n         return new\n \n-    def merge(self, list1, list2):\n+    @property\n+    def css(self):\n+        return self._css\n+\n+    def __str__(self):\n+        return self.render()\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists of items, preserving order and removing duplicates.\n-        The order of items in list2 is preserved, and items from list2 are\n-        appended to list1.\n+        Merge lists of items, preserving order and removing duplicates.\n+        The order of items in each list is preserved, unless there are conflicts\n+        between lists.\n         \"\"\"\n-        if list1 == list2:\n-            return list1\n-        # All items in list1 are prerequisites for all items in list2.\n-        # This is the behavior of merging two separate media definitions.\n-        # Any item in list2 that is already in list1 is moved to the end.\n-        out = list1[:]\n-        for item in list2:\n-            if item in out:\n-                out.remove(item)\n-            out.append(item)\n-        if list1 and list2:\n-            # Check for conflicts\n-            for item1 in list1:\n-                for item2 in list2:\n-                    if item1 in self._dependencies and item2 in self._dependencies[item1]:\n-                        warnings.warn(\n-                            'Detected duplicate Media files in an opposite order:\\n'\n-                            '%s\\n%s' % (item2, item1), MediaOrderConflictWarning, stacklevel=2)\n-                        break\n-        # Remember the dependencies for this merge.\n-        for item1 in list1:\n-            for item2 in list2:\n-                self._dependencies[item2].add(item1)\n-        return out\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(OrderedDict.fromkeys(lists[0]))\n \n-    @property\n-    def css(self):\n-        return self._css\n+        # All items in all lists.\n+        all_items = OrderedDict()\n+        # Dependencies of an item, i.e. items that must appear before it.\n+        dependencies = defaultdict(set)\n+        # Items that depend on another item.\n+        dependents = defaultdict(set)\n \n-    @cached_property\n+        for sublist in lists:\n+            # The first item in a sublist has no dependencies within that list.\n+            # Other items depend on the item that came before them in the sublist.\n+            for i, item in enumerate(sublist):\n+                all_items[item] = None\n+                if i > 0:\n+                    predecessor = sublist[i - 1]\n+                    if predecessor != item:\n+                        dependencies[item].add(predecessor)\n+                        dependents[predecessor].add(item)\n+\n+        # Start with items that have no dependencies.\n+        queue = [item for item in all_items if not dependencies[item]]\n+        # An item is 'ready' if all its dependencies have been output.\n+        # 'queue' is the list of ready items.\n+        ready = set(queue)\n+        # The final, sorted list of items.\n+        result = []\n+\n+        while queue:\n+            item = queue.pop(0)\n+            result.append(item)\n+            # Consider items that depend on the one just output.\n+            for dependent in sorted(list(dependents[item])):\n+                # A dependent is ready to be output if all of its\n+                # dependencies have been output.\n+                if dependencies[dependent].issubset(result):\n+                    if dependent not in ready:\n+                        # Add to the end of the queue.\n+                        queue.append(dependent)\n+                        ready.add(dependent)\n+\n+        if len(result) < len(all_items):\n+            # A circular dependency exists.\n+            conflicts = []\n+            for item, deps in dependencies.items():\n+                if item not in result:\n+                    # An item that couldn't be output is part of a cycle.\n+                    for dep in deps:\n+                        if dep not in result:\n+                            # A dependency that couldn't be output is also\n+                            # part of a cycle.\n+                            conflicts.append('%s (depended on by %s)' % (dep, item))\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n' +\n+                '\\n'.join('  %s' % f for f in conflicts),\n+                MediaOrderConflictWarning,\n+                stacklevel=2,\n+            )\n+            # Fall back to original ordering, but with duplicates removed.\n+            result.extend(item for item in all_items if item not in result)\n+\n+        return result\n+\n+    @cached_property\n     def _css(self):\n         if not self._css_lists:\n             return {}\n-        css = defaultdict(list)\n-        for medium, list_ in self._css_lists:\n-            css[medium].extend(list_)\n-\n-        for medium, list_ in css.items():\n-            # De-duplicate.\n-            css[medium] = list(OrderedDict.fromkeys(list_))\n-\n-        # The following check is for backwards compatibility, for people who\n-        # are not using separate CSS files for different media types.\n-        # See ticket #12879.\n-        if 'all' in css:\n-            for medium, paths in css.items():\n-                if medium == 'all':\n-                    continue\n-                # We have to combine 'all' and the other media type.\n-                css[medium] = self.merge(css['all'], paths)\n-        return dict(css)\n+        css = {}\n+        for medium, sublist in self._css_lists:\n+            css.setdefault(medium, []).append(sublist)\n+        for medium, lists in css.items():\n+            css[medium] = self.merge(*filter(None, lists))\n+        return css\n \n     @property\n     def js(self):\n@@ -120,11 +126,7 @@\n     def _js(self):\n         if not self._js_lists:\n             return []\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        js = self._js_lists[0]\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        return self.merge(*filter(None, self._js_lists))\n \n     def render_js(self):\n         return [\n\n```"}
{"instance_id": "django__django-11039", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -69,8 +69,9 @@\n         # Get the migration\n         migration = executor.loader.get_migration_by_prefix(app_label, migration_name)\n \n-        # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+        # Show begin/end around output for atomic migrations, if the database\n+        # supports transactional DDL.\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -472,6 +472,20 @@\n         self.assertNotIn('BEGIN;', output)\n         self.assertNotIn(connection.ops.start_transaction_sql(), output)\n \n+    @mock.patch('django.db.connection.features')\n+    def test_sqlmigrate_for_db_without_transactional_ddl(self, features):\n+        \"\"\"\n+        sqlmigrate doesn't wrap migrations in a transaction on databases that\n+        don't support transactional DDL.\n+        \"\"\"\n+        features.can_rollback_ddl = False\n+        # The migrations in migrations.test_migrations are atomic.\n+        out = io.StringIO()\n+        call_command('sqlmigrate', 'migrations', '0001', stdout=out)\n+        output = out.getvalue()\n+        self.assertIn('CREATE TABLE \"migrations_author\"', output)\n+        self.assertNotIn(connection.ops.start_transaction_sql(), output)\n+\n     def test_sqlmigrate_app_label_no_migrations_module(self):\n         \"\"\"\n         `sqlmigrate` fails if an app label is provided that doesn't have a\n\n```"}
{"instance_id": "django__django-11049", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/core/validators.py b/django/core/validators.py\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -810,7 +810,7 @@\n def validate_duration(value):\n     if not isinstance(value, str) or parse_duration(value) is None:\n         raise ValidationError(\n-            _('\u201c%(value)s\u201d value has an invalid format. It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.'),\n+            _('\u201c%(value)s\u201d value has an invalid format. It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.'),\n             code='invalid_duration',\n             params={'value': value},\n         )\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1595,8 +1595,8 @@\n     empty_strings_allowed = False\n     default_error_messages = {\n         'invalid': _(\n-            \"'%(value)s' value has an invalid format. It must be in \"\n-            \"[DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"'%(value)s' value has an invalid format. It must be in \"\n+            \"[DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         ),\n     }\n     description = _(\"Duration\")\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -743,8 +743,14 @@\n class DurationField(Field):\n     widget = TextInput\n     default_error_messages = {\n-        'invalid': _('Enter a valid duration.'),\n+        'invalid': _('Enter a valid duration in [DD] [[HH:]MM:]ss[.uuuuuu] format.'),\n     }\n \n+    def __init__(self, **kwargs):\n+        if 'help_text' not in kwargs:\n+            # The format is not self-explanatory, so help text is needed.\n+            kwargs['help_text'] = _('[DD] [[HH:]MM:]ss[.uuuuuu]')\n+        super().__init__(**kwargs)\n+\n     def to_python(self, value):\n         \"\"\"\n         Validate that the input can be converted to a timedelta. Return a\n\n```"}
{"instance_id": "django__django-11099", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex 8b1581111f..e72c5f5f49 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,7 +17,7 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n\n```"}
{"instance_id": "django__django-11133", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -229,9 +229,11 @@\n         # Handle string types -- we can't rely on force_bytes here because:\n         # - Python attempts str conversion first\n         # - when self._charset != 'utf-8' it re-encodes the content\n-        if isinstance(value, bytes):\n-            return value\n+        # Accept bytes-like objects to avoid falling back to their string\n+        # representation.\n+        if isinstance(value, (bytes, memoryview)):\n+            return bytes(value)\n         if isinstance(value, str):\n             return value.encode(self.charset)\n         # Handle other objects by converting them to a string first.\n@@ -308,7 +310,7 @@\n     @content.setter\n     def content(self, value):\n         # Consume iterators upon assignment to allow repeated iteration.\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n+        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str, memoryview)):\n             content = b''.join(self.make_bytes(chunk) for chunk in value)\n             if hasattr(value, 'close'):\n                 try:\n\n```"}
{"instance_id": "django__django-11179", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -277,6 +277,7 @@ class Collector:\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n\n```"}
{"instance_id": "django__django-11283", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -1,40 +1,70 @@\n-from django.db import migrations\n+from django.conf import settings\n+from django.db import IntegrityError, migrations\n \n \n def forwards(apps, schema_editor):\n-    # No imported model classes outside of this migration, but there are\n-    # cached model states from which we can rehydrate models.\n     Permission = apps.get_model('auth', 'Permission')\n     ContentType = apps.get_model('contenttypes', 'ContentType')\n+    Group = apps.get_model('auth', 'Group')\n+\n+    # Get the historical user model.\n+    app_label, model_name = settings.AUTH_USER_MODEL.split('.')\n+    UserModel = apps.get_model(app_label, model_name)\n \n     db_alias = schema_editor.connection.alias\n \n     # Update permission codenames of proxy models to use the model name of the\n-    # concrete class the proxy was for. Permission codenames that would clash\n-    # (because of user renaming a concrete model to clash with the proxy model's\n-    # would occur already by users. Unlikely but complain loudly if it happens.\n-    concrete_model_permissions = set(\n-        Permission.objects.using(db_alias).filter(\n-            content_type__in=ContentType.objects.using(db_alias).filter(proxy_model__isnull=True),\n-        ).values_list('content_type', 'codename')\n-    )\n-    for permission in Permission.objects.using(db_alias).filter(content_type__proxy_model__isnull=False):\n-        concrete_model = permission.content_type.model_class()._meta.concrete_model\n-        concrete_ct = ContentType.objects.db_manager(db_alias).get_for_model(concrete_model)\n-        if (concrete_ct.pk, permission.codename) in concrete_model_permissions:\n-            raise RuntimeError(\n-                \"Couldn't update proxy permission %s because the target \"\n-                \"permission %s already exists.\" % (permission, permission.codename)\n-            )\n-        permission.content_type = concrete_ct\n-        permission.save(update_fields={'content_type'}, using=db_alias)\n+    # concrete class the proxy was for. Where a target permission already\n+    # exists (e.g. it was created earlier by the post_migrate handler, or\n+    # because a concrete model once occupied the same place) reuse the existing\n+    # permission and repoint any m2m relations to it rather than raising an\n+    # IntegrityError (#30595).\n+\n+    # Cache for ContentTypes of concrete models to avoid extra queries.\n+    cached_ct = {}\n+\n+    # Through models for the M2M relations that reference Permission.\n+    group_perm_through = Group.permissions.through\n+    user_perm_through = UserModel.user_permissions.through\n+\n+    proxy_perms = Permission.objects.using(db_alias).filter(\n+        content_type__proxy_model__isnull=False,\n+    ).select_related('content_type')\n+\n+    for perm in proxy_perms:\n+        model_class = perm.content_type.model_class()\n+        # Occasionally stale content types remain without matching models.\n+        if model_class is None or not model_class._meta.proxy:\n+            continue\n+\n+        concrete_model = model_class._meta.concrete_model\n+        concrete_ct = cached_ct.get(concrete_model)\n+        if concrete_ct is None:\n+            concrete_ct = ContentType.objects.db_manager(db_alias).get_for_model(concrete_model)\n+            cached_ct[concrete_model] = concrete_ct\n+\n+        # Skip if already correct.\n+        if perm.content_type_id == concrete_ct.pk:\n+            continue\n+\n+        perm.content_type = concrete_ct\n+        try:\n+            perm.save(update_fields={'content_type'}, using=db_alias)\n+        except IntegrityError:\n+            # Target permission already exists. Reuse it and migrate relations.\n+            target = Permission.objects.using(db_alias).get(\n+                content_type=concrete_ct,\n+                codename=perm.codename,\n+            )\n+            # Update M2M relations to point to the existing permission.\n+            group_perm_through.objects.using(db_alias).filter(\n+                permission_id=perm.pk,\n+            ).update(permission_id=target.pk)\n+            user_perm_through.objects.using(db_alias).filter(\n+                permission_id=perm.pk,\n+            ).update(permission_id=target.pk)\n+            # Finally, delete the redundant permission.\n+            perm.delete(using=db_alias)\n \n \n class Migration(migrations.Migration):\n-\n     dependencies = [\n         ('auth', '0010_alter_group_name_max_length'),\n+        ('contenttypes', '0002_remove_content_type_name'),\n     ]\n \n     operations = [\n\n```"}
{"instance_id": "django__django-11422", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -196,20 +196,27 @@\n         # The directory of the project.\n         self.watched_dir = Path.cwd()\n         for module in list(sys.modules.values()):\n-            spec = getattr(module, '__spec__', None)\n+            # The __spec__ is not set for modules that are not imported\n+            # correctly, such as __main__.\n+            spec = getattr(module, '__spec__', None)\n+            origin = None\n             if spec is None:\n-                continue\n-            # We only want to watch the file if it has a location and it's not\n-            # a C-extension.\n-            if getattr(spec, 'has_location', False) and not spec.origin.endswith('.so'):\n-                # Some packages are zip files, so they don't have a valid\n-                # location.\n-                try:\n-                    location = Path(spec.origin)\n-                except TypeError:\n-                    continue\n+                # The one exception is __main__ which has a __file__ attribute\n+                # that we can watch.\n+                if getattr(module, '__name__', None) == '__main__':\n+                    origin = getattr(module, '__file__', None)\n+            elif getattr(spec, 'has_location', False):\n+                origin = spec.origin\n \n-                # If the file is not in the current directory, we don't\n-                # want to watch it.\n-                if self.watched_dir in location.parents:\n-                    yield location\n+            if origin is None or origin.endswith(('.so', '.pyc')):\n+                continue\n+\n+            # Some packages are zip files, so they don't have a valid\n+            # location.\n+            try:\n+                location = Path(origin)\n+            except TypeError:\n+                continue\n+\n+            # If the file is not in the current directory, we don't\n+            # want to watch it.\n+            if self.watched_dir in location.parents:\n+                yield location\n\n```"}
{"instance_id": "django__django-11564", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -1,5 +1,6 @@\n import os\n from urllib.parse import urljoin\n+from django.urls import get_script_prefix\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured, SuspiciousFileOperation\n@@ -111,7 +112,18 @@\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n-        return urljoin(self.base_url, filepath_to_uri(name))\n+        url = urljoin(self.base_url, filepath_to_uri(name))\n+\n+        # If the base_url is relative to the domain (starts with '/'), prefix it\n+        # with the current SCRIPT_NAME (a.k.a. the URL configuration prefix)\n+        # unless it's already present. This mirrors the behavior of\n+        # django.urls.reverse() and allows projects deployed under a sub-path\n+        # to work without hard-coding the prefix in *_URL settings.\n+        if self.base_url.startswith('/') and not self.base_url.startswith('//'):\n+            script_prefix = get_script_prefix()\n+            if script_prefix and not url.startswith(script_prefix):\n+                url = urljoin(script_prefix, url.lstrip('/'))\n+        return url\n \n     def _save(self, name, content):\n         full_path = self.path(name)\n\n```"}
{"instance_id": "django__django-11583", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -130,7 +130,12 @@ def iter_modules_and_files(modules, extra_files=()):\n             if not path.exists():\n                 # The module could have been removed, don't fail loudly if this\n                 # is the case.\n                 continue\n-            results.add(path.resolve().absolute())\n+            try:\n+                results.add(path.resolve().absolute())\n+            except ValueError:\n+                # path.resolve() may fail on some systems with an\n+                # embedded null byte.\n+                continue\n     return frozenset(results)\n \n \n@@ -173,7 +178,12 @@ def sys_path_directories():\n         path = Path(path)\n         if not path.exists():\n             continue\n-        path = path.resolve().absolute()\n+        try:\n+            path = path.resolve().absolute()\n+        except ValueError:\n+            # path.resolve() may fail on some systems with an\n+            # embedded null byte.\n+            continue\n         # If the path is a file (like a zip file), watch the parent directory.\n         if path.is_file():\n             yield path.parent\n\n```"}
{"instance_id": "django__django-11620", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/views/debug.py b/django/views/debug.py\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -5,7 +5,7 @@ import types\n from pathlib import Path\n \n from django.conf import settings\n-from django.http import HttpResponse, HttpResponseNotFound\n+from django.http import Http404, HttpResponse, HttpResponseNotFound\n from django.template import Context, Engine, TemplateDoesNotExist\n from django.template.defaultfilters import pprint\n from django.template.loader import get_template\n@@ -485,7 +485,7 @@ def technical_404_response(request, exception):\n         resolver_match = resolve(request.path_info)\n         callback, param_dict = resolver_match.func, resolver_match.kwargs\n         view_name = callback.__module__ + '.' + callback.__name__\n-    except Resolver404:\n+    except Http404:\n         callback = resolver_match = view_name = None\n \n     t = get_template('technical_404.html')\n\n```"}
{"instance_id": "django__django-11630", "model_name_or_path": "parallelsynthetize_router", "model_patch": "", "error": "The model response did not complete successfully.\nFinish reason: 2.\nFinish message: .\nSafety ratings: [].\nTo protect the integrity of the chat session, the request and response were not added to chat history.\nTo skip the response validation, specify `model.start_chat(response_validation=False)`.\nNote that letting blocked or otherwise incomplete responses into chat history might lead to future interactions being blocked by the service."}
{"instance_id": "django__django-11742", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -256,6 +256,7 @@ class Field(RegisterLookupMixin):\n             *self._check_choices(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n+            *self._check_max_length_fits_longest_choice(),\n             *self._check_backend_specific_checks(**kwargs),\n             *self._check_validators(),\n             *self._check_deprecation_details(),\n@@ -308,6 +309,29 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_max_length_fits_longest_choice(self):\n+        if not hasattr(self, \"max_length\") or self.max_length is None or not self.choices:\n+            return []\n+\n+        # self.flatchoices flattens choices (including groups).\n+        str_choices = [\n+            value for value, _ in self.flatchoices if isinstance(value, str)\n+        ]\n+\n+        if not str_choices:\n+            return []\n+\n+        longest_choice = max(len(value) for value in str_choices)\n+        if longest_choice > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"'max_length' is too small to fit the longest choice value \"\n+                    \"(%d characters).\" % longest_choice,\n+                    obj=self,\n+                    id=\"fields.E009\",\n+                )\n+            ]\n+        return []\n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n\n```"}
{"instance_id": "django__django-11797", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -252,9 +252,13 @@\n         from django.db.models.sql.query import Query\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n-                # The subquery must select only the pk.\n-                self.rhs.clear_select_clause()\n-                self.rhs.add_fields(['pk'])\n+                # Respect the select list of subqueries that already specify\n+                # explicit fields. Only force the primary key when no fields\n+                # have been selected yet. This prevents inadvertent removal of\n+                # required selected columns (e.g. those referenced in a GROUP\n+                # BY clause).\n+                if not getattr(self.rhs, 'has_select_fields', True):\n+                    self.rhs.clear_select_clause()\n+                    self.rhs.add_fields(['pk'])\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\n\n```"}
{"instance_id": "django__django-11815", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..b00c6f0df2 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,9 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n+        _, v_imports = serializer_factory(self.value.value).serialize()\n         imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        return \"%s.%s[%r]\" % (module, enum_class.__name__, self.value.name), imports\n \n \n class FloatSerializer(BaseSimpleSerializer):\n\n```"}
{"instance_id": "django__django-11848", "model_name_or_path": "parallelsynthetize_router", "model_patch": "", "error": "The model response did not complete successfully.\nFinish reason: 2.\nFinish message: .\nSafety ratings: [].\nTo protect the integrity of the chat session, the request and response were not added to chat history.\nTo skip the response validation, specify `model.start_chat(response_validation=False)`.\nNote that letting blocked or otherwise incomplete responses into chat history might lead to future interactions being blocked by the service."}
{"instance_id": "django__django-11905", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -1,6 +1,7 @@\n import itertools\n import math\n import uuid\n+import warnings\n from copy import copy\n \n from django.core.exceptions import EmptyResultSet\n@@ -11,6 +12,7 @@\n )\n from django.db.models.query_utils import RegisterLookupMixin\n from django.utils.datastructures import OrderedSet\n+from django.utils.deprecation import RemovedInDjango40Warning\n from django.utils.functional import cached_property\n \n \n@@ -463,6 +465,13 @@\n     prepare_rhs = False\n \n     def as_sql(self, compiler, connection):\n+        if not isinstance(self.rhs, bool):\n+            warnings.warn(\n+                'Using a non-boolean value for an isnull lookup is '\n+                'deprecated, use True or False instead.',\n+                RemovedInDjango40Warning,\n+                stacklevel=2\n+            )\n         sql, params = compiler.compile(self.lhs)\n         if self.rhs:\n             return \"%s IS NULL\" % sql, params\n\n```"}
{"instance_id": "django__django-11910", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -801,5 +801,12 @@\n         name, path, args, kwargs = super().deconstruct()\n         # If to_field is not specified, work it out from the relation\n-        if self.remote_field.field_name:\n-            kwargs['to_field'] = self.remote_field.field_name\n+        # Include `to_field` only when it was explicitly set (i.e. it's\n+        # different from the target model's primary key). This prevents\n+        # unnecessary AlterField operations with a stale primary key name\n+        # being generated when the target model's primary key is renamed.\n+        if (\n+            self.remote_field.field_name and\n+            self.remote_field.field_name != self.remote_field.model._meta.pk.name\n+        ):\n+            kwargs['to_field'] = self.remote_field.field_name\n \n         if self.db_constraint is not True:\n             kwargs['db_constraint'] = self.db_constraint\n@@ -1193,5 +1200,12 @@\n         name, path, args, kwargs = super().deconstruct()\n         # If to_field is not specified, work it out from the relation\n-        if self.remote_field.field_name:\n-            kwargs['to_field'] = self.remote_field.field_name\n+        # Include `to_field` only when it was explicitly set (i.e. it's\n+        # different from the target model's primary key). This prevents\n+        # unnecessary AlterField operations with a stale primary key name\n+        # being generated when the target model's primary key is renamed.\n+        if (\n+            self.remote_field.field_name and\n+            self.remote_field.field_name != self.remote_field.model._meta.pk.name\n+        ):\n+            kwargs['to_field'] = self.remote_field.field_name\n \n         if 'through' in self._unspecified_through:\n             kwargs.pop('through', None)\n\n```"}
{"instance_id": "django__django-11964", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -1,5 +1,6 @@\n import copy\n import functools\n+import enum\n from collections import namedtuple\n \n from django.core.exceptions import FieldError, MultipleObjectsReturned, ObjectDoesNotExist\n@@ -21,7 +22,13 @@\n         self.field_name = field.name\n \n     def __set__(self, instance, value):\n-        instance.__dict__[self.field_name] = value\n+        # If the value is an Enum (e.g. members of models.TextChoices or\n+        # models.IntegerChoices), store its underlying value instead of the\n+        # Enum instance itself. This ensures consistency between freshly\n+        # created instances and those retrieved from the database.\n+        if isinstance(value, enum.Enum):\n+            value = value.value\n+        instance.__dict__[self.field_name] = value\n \n     def __get__(self, instance, cls=None):\n         \"\"\"\n\n```"}
{"instance_id": "django__django-11999", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -771,13 +771,18 @@\n         if not private_only:\n             cls._meta.add_field(self)\n \n         # Add the get_FOO_display() method to the class.\n         if self.choices:\n-            setattr(\n-                cls,\n-                'get_%s_display' % self.name,\n-                partialmethod(cls._get_FIELD_display, field=self),\n-            )\n+            # Don't override a get_FOO_display() method explicitly defined on\n+            # the model class. Respecting an existing method allows users to\n+            # customize the display value regardless of the order in which\n+            # the field and the method are declared.\n+            display_method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, display_method_name):\n+                setattr(\n+                    cls,\n+                    display_method_name,\n+                    partialmethod(cls._get_FIELD_display, field=self),\n+                )\n \n         if self.column is None:\n             self.column = self.name\n\n```"}
{"instance_id": "django__django-12113", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -1,19 +1,38 @@\n+import os\n from sys import version_info\n \n from django.db.backends.base.creation import BaseDatabaseCreation\n \n \n class DatabaseCreation(BaseDatabaseCreation):\n \n-    def _get_test_db_name(self):\n+    def test_db_signature(self):\n         \"\"\"\n-        Return the name of the test database.\n+        Return a tuple that uniquely identifies the test database.\n+\n+        When TEST['NAME'] is specified, use its absolute path so that aliases\n+        pointing at the same database file get the same signature. This\n+        prevents creating a clone of the same SQLite database file which can\n+        lead to \"database is locked\" errors.\n         \"\"\"\n-        test_database_name = self.connection.settings_dict['TEST']['NAME']\n-        if test_database_name and test_database_name != ':memory:':\n-            return test_database_name\n+        settings_dict = self.connection.settings_dict\n+        test_database_name = self._get_test_db_name()\n+        if test_database_name and test_database_name != ':memory:':\n+            # Normalize the path to ensure consistent signatures.\n+            test_database_name = os.path.abspath(test_database_name)\n+        return (\n+            settings_dict['ENGINE'],\n+            test_database_name,\n+        )\n+\n+    def _get_test_db_name(self):\n+        \"\"\"Return the name of the test database.\"\"\"\n+        settings_dict = self.connection.settings_dict\n+        test_name = settings_dict['TEST'].get('NAME')\n+        if test_name and test_name != ':memory:':\n+            return test_name\n         return ':memory:'\n \n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         # Don't import django.core.management if it isn't needed.\n\n```"}
{"instance_id": "django__django-12125", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -264,4 +264,4 @@\n \n class TypeSerializer(BaseSerializer):\n     def serialize(self):\n-        return self.value.__name__, {'import %s' % self.value.__module__}\n+        return self.value.__qualname__, {'import %s' % self.value.__module__}\n\n```"}
{"instance_id": "django__django-12184", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -253,16 +253,15 @@ class RegexURLPattern:\n         if match:\n             kwargs = match.groupdict()\n             # In path(), all unnamed groups are ignored. In re_path(), they\n-            # are provided as positional arguments.\n-            args = () if kwargs else match.groups()\n-\n-            # For both path() and re_path(), None is converted to '' for string\n-            # arguments.\n-            for k, v in kwargs.items():\n-                if v is None:\n-                    kwargs[k] = ''\n-            args = tuple(x if x is not None else '' for x in args)\n-\n+            # are provided as positional arguments. An optional group that\n+            # doesn't match has a value of None.\n+            if kwargs:\n+                args = ()\n+                kwargs = {k: v for k, v in kwargs.items() if v is not None}\n+            else:\n+                args = tuple(\n+                    x if x is not None else '' for x in match.groups()\n+                )\n             return ResolverMatch(\n                 self.callback,\n                 args,\n\n```"}
{"instance_id": "django__django-12284", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -741,7 +741,7 @@\n         if self.choices:\n             # Don't override a get_FOO_display() method defined explicitly\n             # on the model.\n-            if not hasattr(cls, 'get_%s_display' % self.name):\n+            if 'get_%s_display' % self.name not in cls.__dict__:\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n\n```"}
{"instance_id": "django__django-12286", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/core/checks/translation.py b/django/core/checks/translation.py\n--- a/django/core/checks/translation.py\n+++ b/django/core/checks/translation.py\n@@ -1,5 +1,6 @@\n from django.conf import settings\n from django.core.checks import Error, Tags, Warning, register\n+from django.utils.translation import get_supported_language_variant\n from django.utils.translation import gettext_lazy as _\n \n E001 = Warning(\n@@ -37,8 +38,10 @@\n     if settings.USE_I18N:\n         if not settings.LANGUAGE_CODE:\n             errors.append(E003)\n-        elif settings.LANGUAGE_CODE not in dict(settings.LANGUAGES):\n-            errors.append(E004)\n+        else:\n+            try:\n+                get_supported_language_variant(settings.LANGUAGE_CODE)\n+            except LookupError:\n+                errors.append(E004)\n     return errors\n\n```"}
{"instance_id": "django__django-12308", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -1,4 +1,5 @@\n-from functools import partial\n+import json\n+from functools import partial\n \n from django.core.exceptions import ObjectDoesNotExist\n from django.db import models\n@@ -258,6 +259,14 @@\n     elif isinstance(field, models.BooleanField):\n         return _boolean_icon(value)\n+    elif hasattr(models, 'JSONField') and isinstance(field, models.JSONField):\n+        try:\n+            json_str = json.dumps(value, cls=field.encoder, indent=2)\n+            return format_html('<pre>{}</pre>', json_str)\n+        except TypeError:\n+            # Not a JSON serializable type.\n+            return display_for_value(value, empty_value_display)\n     elif isinstance(field, (models.DateField, models.TimeField)):\n         return formats.localize(value)\n     elif isinstance(field, models.DecimalField):\n\n```"}
{"instance_id": "django__django-12453", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -4,7 +4,7 @@ import time\n from django.apps import apps\n from django.conf import settings\n from django.core import serializers\n-from django.db import router\n+from django.db import router, transaction\n from django.utils.six import StringIO\n from django.utils.six.moves import input\n \n@@ -128,8 +128,12 @@ class BaseDatabaseCreation(object):\n \t\tthe serialize_db_to_string method.\n \t\t\"\"\"\n \t\tdata = StringIO(data)\n-\t\tfor obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-\t\t\tobj.save()\n+\t\tusing = self.connection.alias\n+\t\twith transaction.atomic(using=using):\n+\t\t\twith self.connection.constraint_checks_disabled():\n+\t\t\t\tfor obj in serializers.deserialize(\"json\", data, using=using):\n+\t\t\t\t\tobj.save()\n+\t\t\tself.connection.check_constraints()\n \n \tdef _get_database_display_str(self, verbosity, database_name):\n \t\t\"\"\"\n\n```"}
{"instance_id": "django__django-12470", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -376,9 +376,10 @@\n                     for i, field in enumerate(ordering):\n                         if 'pk' in field:\n                             # This is a hack, but it is the only way to handle\n                             # this case.\n-                            parent_pk = field.split('__')[0] + '_ptr'\n-                            if parent_pk in [f.name for f in self.local_fields]:\n-                                ordering[i] = field.replace('pk', self.pk.name)\n+                            field_name = field.lstrip('-')\n+                            if (field_name == 'pk' and self.pk.remote_field or\n+                                    field_name.split('__', 1)[0] + '_ptr' in\n+                                    (f.name for f in self.local_fields)):\n+                                ordering[i] = field.replace('pk', self.pk.name)\n                     return tuple(ordering)\n                 return ()\n \n\n```"}
{"instance_id": "django__django-12497", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1885,13 +1885,9 @@\n             if self.remote_field.model == self.model:\n                 # Recursive relationship\n                 hint = (\n-                    'If you want to create a recursive relationship, '\n-                    'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n-                    % (\n-                        self.remote_field.model._meta.object_name,\n-                        through_model._meta.object_name,\n-                    )\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"%s\").'\n+                    % through_model._meta.label\n                 )\n             else:\n                 hint = None\n\n```"}
{"instance_id": "django__django-12589", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1763,13 +1763,25 @@\n         if self.select_related:\n             self.group_by.extend(self.get_related_selections())\n \n+        # A set of all column names, from all tables.\n+        involved_models = {self.model}\n+        for join in self.alias_map.values():\n+            involved_models.add(join.join_field.model)\n+            if join.join_field.related_model:\n+                involved_models.add(join.join_field.related_model)\n+        involved_column_names = {\n+            field.column\n+            for model in involved_models\n+            for field in model._meta.get_fields()\n+            if hasattr(field, 'column')\n+        }\n+\n         for alias, annotation in self.annotation_select.items():\n             if annotation.is_summary:\n                 continue\n             # If the annotation is a database column, it's already in the\n             # GROUP BY clause.\n-            if allow_aliases and alias not in extra_select_aliases:\n+            if allow_aliases and alias not in extra_select_aliases and alias not in involved_column_names:\n                 # We can use an alias in the GROUP BY clause if it's not\n                 # a named column.\n                 self.group_by.append(OrderBy(RawSQL(alias, [])))\n\n```"}
{"instance_id": "django__django-12700", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -211,3 +211,5 @@\n         if isinstance(value, dict):\n             return {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+        if isinstance(value, (list, tuple)):\n+            return type(value)(self.cleanse_setting(key, v) for v in value)\n         return value\n\n```"}
{"instance_id": "django__django-12708", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,7 +375,7 @@\n                 suffix = '_uniq' if unique else '_idx'\n                 name = self._create_index_name(model, fields, suffix=suffix)\n         else:\n-            constraint_names = self._constraint_names(model, fields, index=True)\n+            constraint_names = self._constraint_names(model, fields, index=True, unique=unique)\n             if len(constraint_names) != 1:\n                 raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                     len(constraint_names),\n\n```"}
{"instance_id": "django__django-12747", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -770,5 +770,8 @@\n                 not self._meta.has_auto_field and\n                 all(related.on_delete == DO_NOTHING for related in self._meta.related_objects) and\n                 not self._meta.parents):\n-            deleted = self._raw_delete(using=self.db)\n-            return deleted, {self.model._meta.label: deleted}\n+            deleted = self._raw_delete(using=self.db)\n+            # Don't include model labels with a zero counter to keep the return\n+            # value consistent with the collector-based deletion path.\n+            if deleted == 0:\n+                return 0, {}\n+            return deleted, {self.model._meta.label: deleted}\n \n         collector = Collector(using=self.db)\n         collector.collect(self)\n\n```"}
{"instance_id": "django__django-12856", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -58,6 +58,12 @@\n         self.include = tuple(include) if include else ()\n         super().__init__(*expressions, name=name, condition=condition, deferrable=deferrable, opclasses=opclasses)\n \n+    def check(self, model, **kwargs):\n+        errors = super().check(model, **kwargs)\n+        fields = self.fields + self.include\n+        errors.extend(model._check_local_fields(fields, 'UniqueConstraint'))\n+        return errors\n+\n     def __repr__(self):\n         return '<%s: fields=%s name=%s%s>' % (\n             self.__class__.__name__,\n\n```"}
{"instance_id": "django__django-12908", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1074,5 +1074,11 @@\n     def distinct(self, *fields):\n         \"\"\"Return a new QuerySet instance that will select only distinct results.\"\"\"\n+        if self.query.combinator:\n+            from django.db.utils import NotSupportedError\n+            raise NotSupportedError(\n+                \"distinct() is not supported on querysets that use \"\n+                \"union(), intersection(), or difference().\"\n+            )\n         self._validate_values_are_expressions(fields)\n         clone = self._clone()\n         clone.query.add_distinct_fields(fields)\n\n```"}
{"instance_id": "django__django-12915", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/staticfiles/handlers.py\n+++ b/django/contrib/staticfiles/handlers.py\n@@ -1,5 +1,6 @@\n import os\n \n+from asgiref.sync import sync_to_async\n from django.conf import settings\n from django.contrib.staticfiles import finders\n from django.contrib.staticfiles.views import serve\n@@ -62,6 +63,14 @@\n         \"\"\"\n         return self.base_url.path in path and \"..\" not in path\n \n+    async def get_response_async(self, request):\n+        if self._should_handle(request.path_info):\n+            try:\n+                return await sync_to_async(self.serve, thread_sensitive=True)(request)\n+            except Http404:\n+                pass\n+        return await super().get_response_async(request)\n+\n \n class StaticFilesHandler(StaticFilesHandlerMixin, WSGIHandler):\n     \"\"\"\n\n```"}
{"instance_id": "django__django-12983", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/utils/text.py\n+++ b/django/utils/text.py\n@@ -424,14 +424,16 @@\n @keep_lazy_text\n def slugify(value, allow_unicode=False):\n     \"\"\"\n-    Convert to ASCII if 'allow_unicode' is False. Convert spaces to hyphens.\n-    Remove characters that aren't alphanumerics, underscores, or hyphens.\n-    Convert to lowercase. Also strip leading and trailing whitespace.\n+    Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated\n+    dashes to single dashes. Remove characters that aren't alphanumerics,\n+    underscores, or hyphens. Convert to lowercase. Also strip leading and\n+    trailing whitespace, dashes, and underscores.\n     \"\"\"\n     value = str(value)\n     if allow_unicode:\n         value = unicodedata.normalize('NFKC', value)\n         value = re.sub(r'[^\\w\\s-]', '', value, flags=re.U).strip().lower()\n-        return re.sub(r'[-\\s]+', '-', value, flags=re.U)\n+        return re.sub(r'[-\\s]+', '-', value, flags=re.U).strip('_-')\n     value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')\n     value = re.sub(r'[^\\w\\s-]', '', value).strip().lower()\n-    return re.sub(r'[-\\s]+', '-', value)\n+    return re.sub(r'[-\\s]+', '-', value).strip('_-')\n\n```"}
{"instance_id": "django__django-13028", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1127,11 +1127,18 @@\n         self.annotation_select_mask = set(self.annotation_select)\n \n     def check_filterable(self, expression):\n-        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        \"\"\"\n+        Raise an error if expression cannot be used in a WHERE clause.\n+\n+        Only Expression objects (i.e. objects providing the\n+        resolve_expression() method) can set `filterable=False` to opt-out\n+        from being used in WHERE clauses. Avoid triggering this check for\n+        regular Python values that might legitimately define a `filterable`\n+        attribute for other purposes (e.g. a model instance with a\n+        BooleanField named \"filterable\").\n+        \"\"\"\n+        if hasattr(expression, 'resolve_expression') and not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n             )\n\n```"}
{"instance_id": "django__django-13033", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,7 @@ class SQLCompiler:\n                 # If we get to this point and the field is a relation to another model,\n                 # append the default ordering for that model unless it is the pk\n                 # shortcut or the attribute name of the field that is specified.\n-                if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+                if field.is_relation and opts.ordering and getattr(field, 'attname', None) != pieces[-1] and name != 'pk':\n                     # Firstly, avoid infinite loops.\n                     already_seen = already_seen or set()\n                     join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n\n```"}
{"instance_id": "django__django-13158", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1154,6 +1154,8 @@\n         If 'with_col_aliases' is true, any column names that are duplicated\n         across the subqueries will be aliased to ensure they are unique.\n         \"\"\"\n+        if self.query.where.is_never:\n+            raise EmptyResultSet\n         if self.query.combinator == 'UNION' and not self.query.all and not with_col_aliases:\n             # The columns of all SELECTs in a UNION must be in the same order.\n             # The first query in the UNION determines the order.\n\n```"}
{"instance_id": "django__django-13220", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -117,6 +117,47 @@\n \n     __repr__ = __str__\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return self._normalize(self.get_full_details()) == self._normalize(other.get_full_details())\n+\n+    def __hash__(self):\n+        return hash(self._to_hashable(self._normalize(self.get_full_details())))\n+\n+    def _normalize(self, details):\n+        \"\"\"\n+        Recursively normalize details so that lists are made order-\n+        independent (by sorting their items) and dictionaries are transformed\n+        into regular Python dicts with their values also normalized.\n+        \"\"\"\n+        if isinstance(details, list):\n+            # Sort list items to guarantee order independence.\n+            return sorted((self._normalize(item) for item in details), key=self._to_sort_key)\n+        if isinstance(details, dict) and {'message', 'code'}.issubset(details.keys()):\n+            # A single error detail.\n+            return {\n+                'message': details.get('message'),\n+                'code': details.get('code'),\n+                'params': details.get('params'),\n+            }\n+        if isinstance(details, dict):\n+            # A dictionary of field names to lists of errors.\n+            return {key: self._normalize(value) for key, value in details.items()}\n+        return details\n+\n+    def _to_sort_key(self, value):\n+        \"\"\"Produce a consistent sort key for list items.\"\"\"\n+        if isinstance(value, dict):\n+            return sorted(value.items())\n+        return value\n+\n+    def _to_hashable(self, value):\n+        \"\"\"Convert value produced by _normalize() into a hashable structure.\"\"\"\n+        if isinstance(value, list):\n+            return tuple(self._to_hashable(v) for v in value)\n+        if isinstance(value, dict):\n+            return tuple(sorted((k, self._to_hashable(v)) for k, v in value.items()))\n+        return value\n+\n     def __iter__(self):\n         if hasattr(self, 'error_dict'):\n             for field, errors in self.error_dict.items():\n\n```"}
{"instance_id": "django__django-13230", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/syndication/views.py\n+++ b/django/contrib/syndication/views.py\n@@ -151,6 +151,7 @@\n             item_updateddate = self._get_dynamic_attr(\"item_updateddate\", item)\n             item_enclosures = self._get_dynamic_attr(\"item_enclosures\", item)\n             item_copyright = self._get_dynamic_attr(\"item_copyright\", item)\n+            item_comments = self._get_dynamic_attr(\"item_comments\", item)\n \n             enclosures = []\n             for enclosure in item_enclosures:\n@@ -168,6 +169,7 @@\n                 author_link=item_author_link,\n                 unique_id=item_guid,\n                 enclosure=enclosures[0] if enclosures else None,\n+                comments=item_comments,\n                 categories=item_categories,\n                 item_copyright=item_copyright,\n                 unique_id_is_permalink=item_guid_is_permalink,\n@@ -202,5 +204,9 @@\n     def item_copyright(self, item):\n         return None\n \n+    def item_comments(self, item):\n+        \"\"\"Take an item, as returned by items(), and return its comments URL.\"\"\"\n+        return None\n+\n     # ITEM METHODS ##########################################################\n \n     def items(self):\n\n```"}
{"instance_id": "django__django-13265", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -482,7 +482,15 @@\n         return name.lower() == self.name_lower\n \n     def references_field(self, model_name, name, app_label=None):\n-        return self.references_model(model_name) and name.lower() == self.order_with_respect_to.lower()\n+        if not self.references_model(model_name, app_label):\n+            return False\n+        # The AlterOrderWithRespectTo operation creates the `_order` field.\n+        if self.order_with_respect_to and name == '_order':\n+            return True\n+        # It also depends on the field in `order_with_respect_to`, so it\n+        # references it.\n+        return self.order_with_respect_to and name.lower() == self.order_with_respect_to.lower()\n \n     def deconstruct(self):\n         kwargs = {\n\n```"}
{"instance_id": "django__django-13315", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -957,11 +957,15 @@\n         db = kwargs.pop('using', None)\n         if isinstance(self.rel.to, basestring):\n             raise ValueError(\"ForeignKey_deferred_class_formfield\")\n-        defaults = {\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.rel.to._default_manager.using(db).complex_filter(self.rel.limit_choices_to),\n-            'to_field_name': self.rel.to_field_name,\n-        }\n+        qs = self.rel.to._default_manager.using(db).complex_filter(\n+            self.rel.limit_choices_to)\n+        if self.rel.limit_choices_to:\n+            qs = qs.annotate().order_by()\n+        defaults = {\n+            'form_class': forms.ModelChoiceField,\n+            'queryset': qs,\n+            'to_field_name': self.rel.to_field_name,\n+        }\n         if self.rel.parent_link:\n             defaults['initial'] = self.rel.to._meta.pk.get_default()\n         defaults.update(kwargs)\n@@ -1243,11 +1247,15 @@\n \n     def formfield(self, **kwargs):\n         db = kwargs.pop('using', None)\n-        defaults = {\n-            'form_class': forms.ModelMultipleChoiceField,\n-            'queryset': self.rel.to._default_manager.using(db).complex_filter(\n-                self.rel.limit_choices_to)\n-        }\n+        qs = self.rel.to._default_manager.using(db).complex_filter(\n+            self.rel.limit_choices_to)\n+        if self.rel.limit_choices_to:\n+            qs = qs.annotate().order_by()\n+        defaults = {\n+            'form_class': forms.ModelMultipleChoiceField,\n+            'queryset': qs,\n+        }\n         defaults.update(kwargs)\n         # If initial is passed in, it's a list of pks.\n         if 'initial' in defaults:\n\n```"}
{"instance_id": "django__django-13321", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -1,5 +1,6 @@\n import base64\n import json\n+from binascii import Error as BinasciiError\n from datetime import datetime, timedelta\n \n from django.conf import settings\n@@ -118,9 +119,13 @@\n             return signing.loads(\n                 session_data, salt=self.key_salt, serializer=self.serializer,\n             )\n         except signing.BadSignature:\n-            # This could be an old session...\n-            return self._legacy_decode(session_data)\n+            try:\n+                # This could be an old session...\n+                return self._legacy_decode(session_data)\n+            except (BinasciiError, TypeError):\n+                # ... or a weird session. Just return an empty dictionary.\n+                return {}\n         except signing.SuspiciousOperation:\n             # ... or a weird session. Just return an empty dictionary.\n             return {}\n\n```"}
{"instance_id": "django__django-13401", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -271,18 +271,21 @@\n     def __eq__(self, other):\n         # Needed for @total_ordering\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            return (self.creation_counter == other.creation_counter and\n+                    self.model is other.model)\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n         if isinstance(other, Field):\n-            return self.creation_counter < other.creation_counter\n+            if self.creation_counter != other.creation_counter:\n+                return self.creation_counter < other.creation_counter\n+            return self.model._meta.label_lower < other.model._meta.label_lower\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash(self.creation_counter)\n+        return hash((self.creation_counter, self.model))\n \n     def deconstruct(self):\n         \"\"\"\n\n```"}
{"instance_id": "django__django-13447", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/admin/sites.py\n+++ b/django/contrib/admin/sites.py\n@@ -282,11 +282,11 @@\n \n         return inner\n \n-    def _build_app_dict(self, request, label=None):\n+    def build_app_dict(self, request, label=None):\n         \"\"\"\n-        Build the app dictionary. The optional `label` parameter filters models\n-        of a specific app.\n+        Build the app list. The optional `label` parameter filters models of a\n+        specific app.\n         \"\"\"\n         app_dict = {}\n \n@@ -314,6 +314,7 @@\n \n             info = (app_label, model._meta.model_name)\n             model_dict = {\n+                'model': model,\n                 'name': capfirst(model._meta.verbose_name_plural),\n                 'object_name': model._meta.object_name,\n                 'perms': perms,\n@@ -358,7 +359,7 @@\n         Display the main admin index page, which lists all of the apps that have\n         been registered in this site.\n         \"\"\"\n-        app_list = self._build_app_dict(request)\n+        app_list = self.build_app_dict(request)\n \n         context = {\n             **self.each_context(request),\n@@ -371,7 +372,7 @@\n         return TemplateResponse(request, self.index_template or 'admin/index.html', context)\n \n     def app_index(self, request, app_label, extra_context=None):\n-        app_list = self._build_app_dict(request, app_label)\n+        app_list = self.build_app_dict(request, app_label)\n         if not app_list:\n             raise Http404('The requested admin page does not exist.')\n         # A list of models for this app and the list of apps.\n\n```"}
{"instance_id": "django__django-13448", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -2,6 +2,8 @@\n import sys\n import time\n \n+from django.apps import apps\n+from django.conf import settings\n from django.core.management import call_command\n from django.db import connections\n from django.utils.functional import cached_property\n@@ -73,6 +75,25 @@\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # Disable migrations and run syncdb.\n+            try:\n+                old_migration_modules = settings.MIGRATION_MODULES\n+                settings.MIGRATION_MODULES = {\n+                    app.label: None\n+                    for app in apps.get_app_configs()\n+                }\n+                call_command(\n+                    'migrate',\n+                    verbosity=max(verbosity - 1, 0),\n+                    interactive=False,\n+                    database=self.connection.alias,\n+                    run_syncdb=True,\n+                )\n+            finally:\n+                settings.MIGRATION_MODULES = old_migration_modules\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is\n\n```"}
{"instance_id": "django__django-13551", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -94,5 +94,6 @@\n         return (\n             six.text_type(user.pk) + user.password +\n-            six.text_type(login_timestamp) + six.text_type(timestamp)\n+            six.text_type(login_timestamp) + six.text_type(timestamp) +\n+            six.text_type(getattr(user, user.get_email_field_name(), ''))\n         )\n \n     def _make_token_with_timestamp(self, user, timestamp, legacy=False):\n\n```"}
{"instance_id": "django__django-13590", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -422,9 +422,15 @@\n         return value.resolve_expression(\n             self, allow_joins=allow_joins, reuse=can_reuse, summarize=False, for_save=False,\n         )\n-    if isinstance(value, (list, tuple)):\n-        return type(value)(\n-            [self.resolve_lookup_value(sub_val, can_reuse, allow_joins) for sub_val in value]\n-        )\n+    if isinstance(value, (list, tuple)):\n+        resolved_values = [\n+            self.resolve_lookup_value(sub_val, can_reuse, allow_joins) for sub_val in value\n+        ]\n+        try:\n+            # Most built-in containers (list, tuple, etc.) can be\n+            # reconstructed from an iterable.\n+            return type(value)(resolved_values)\n+        except TypeError:\n+            # A container (e.g. namedtuple) may expect positional arguments.\n+            return type(value)(*resolved_values)\n     if isinstance(value, QuerySet):\n         if value._fields and not allow_joins:\n             # queryset.values_list(...) -> _fields is not None\n\n```"}
{"instance_id": "django__django-13658", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -102,7 +102,12 @@\n             subcommand = 'help'  # Display help if no arguments were given.\n \n         # Pre-parse the command line to extract top-level options.\n-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n+        parser = CommandParser(\n+            prog=self.prog_name,\n+            usage='%(prog)s subcommand [options] [args]',\n+            add_help=False,\n+            allow_abbrev=False,\n+        )\n         parser.add_argument('--settings')\n         parser.add_argument('--pythonpath')\n         parser.add_argument('args', nargs='*')  # catch-all\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -297,4 +297,17 @@\n                 self.assertEqual(\n                     execute_from_command_line(['django-admin', 'mycommand']),\n                     'mycommand'\n-                )\n+                )\n+\n+    def test_prog_name_from_argv(self):\n+        \"\"\"\n+        ManagementUtility determines prog_name from argv[0] and uses it in\n+        the parser.\n+        \"\"\"\n+        with mock.patch('sys.argv', [None]):\n+            utility = ManagementUtility(['my_prog', 'help'])\n+            self.assertEqual(utility.prog_name, 'my_prog')\n+            with captured_stdout() as stdout:\n+                utility.execute()\n+            self.assertIn(\"Type 'my_prog help <subcommand>' for help on a specific subcommand.\", stdout.getvalue())\n\n```"}
{"instance_id": "django__django-13660", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -83,12 +83,12 @@\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n\n```"}
{"instance_id": "django__django-13710", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -20,7 +20,7 @@\n from django.template.response import SimpleTemplateResponse, TemplateResponse\n from django.utils import six\n from django.utils.deprecation import RemovedInDjango19Warning\n-from django.utils.text import capfirst, get_text_list, unescape_string_literal\n+from django.utils.text import capfirst, format_lazy, get_text_list, unescape_string_literal\n from django.utils.translation import ugettext as _, ugettext_lazy\n \n # Default values for the constructor, see constructor docstring for details.\n@@ -1518,8 +1518,8 @@\n         super(InlineModelAdmin, self).__init__(parent_model, admin_site)\n         if self.verbose_name is None:\n             self.verbose_name = self.model._meta.verbose_name\n         if self.verbose_name_plural is None:\n-            self.verbose_name_plural = self.model._meta.verbose_name_plural\n+            self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n \n     @property\n     def media(self):\n\n```"}
{"instance_id": "django__django-13757", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/backends/oracle/operations.py\n+++ b/django/db/backends/oracle/operations.py\n@@ -322,9 +322,17 @@ class DatabaseOperations(BaseDatabaseOperations):\n     def date_interval_sql(self, timedelta):\n         return \"NUMTODSINTERVAL(%s, 'SECOND')\" % timedelta.total_seconds()\n \n     def json_key_transform_sql(self, key, column):\n-        return \"JSON_QUERY(%s, '$.%s')\" % (column, key)\n+        return \"JSON_QUERY(%s, '%s')\" % (column, self._get_json_path(key))\n \n     def explain_query_prefix(self, format=None, **options):\n         if format:\n             return 'EXPLAIN PLAN FOR'\n+\n+    def json_haskey_sql(self, column, key):\n+        return \"JSON_EXISTS(%s, '%s')\" % (column, self._get_json_path(key))\n+\n+    def _get_json_path(self, key):\n+        return '$.%s' % key\n+\n     def pk_default_value(self):\n         return \"NULL\"\n \n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -262,8 +262,14 @@ class DatabaseOperations(BaseDatabaseOperations):\n         # https://sqlite.org/json1.html#jex\n         return 'JSON_EXTRACT(%s, %s)' % (column, ', '.join(['%s'] * len(path)))\n \n-    def json_key_transform_sql(self, key, column):\n-        return 'JSON_EXTRACT(%s, %s)' % (column, \"'$.\" + key + \"'\")\n+    def json_key_transform_sql(self, key, column):\n+        return 'JSON_EXTRACT(%s, %s)' % (column, self._get_json_path(key))\n+\n+    def json_haskey_sql(self, column, key):\n+        return 'JSON_TYPE(%s, %s) IS NOT NULL' % (column, self._get_json_path(key))\n+\n+    def _get_json_path(self, key):\n+        return \"'$.\" + key + \"'\"\n \n     def get_db_converters(self, expression):\n         converters = super().get_db_converters(expression)\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -325,8 +325,19 @@\n \n \n @KeyTransform.register_lookup\n class KeyTransformIsNull(IsNull):\n-    pass\n+    def as_sql(self, compiler, connection):\n+        # A JSON key is considered \"null\" only when it's missing. A key that's\n+        # present with the JSON value `null` must not be matched when\n+        # `__isnull=True` is used.\n+        has_key = HasKey(self.lhs.lhs, self.lhs.key_name)\n+        has_key_sql, has_key_params = has_key.as_sql(compiler, connection)\n+        if self.rhs:\n+            # __isnull=True: key does not exist.\n+            return f\"NOT ({has_key_sql})\", has_key_params\n+        # __isnull=False: key exists.\n+        return has_key_sql, has_key_params\n \n \n class JSONField(Field):\n\n```"}
{"instance_id": "django__django-13768", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/dispatch/dispatcher.py\n+++ b/django/dispatch/dispatcher.py\n@@ -1,5 +1,8 @@\n+import logging\n import weakref\n \n from django.utils.inspect import func_accepts_kwargs\n from django.utils.weakref import WeakMethod\n+\n+\n+logger = logging.getLogger('django.dispatch')\n \n \n class Signal:\n@@ -194,6 +197,7 @@\n             for receiver in self._live_receivers(sender):\n                 try:\n                     response = receiver(signal=self, sender=sender, **named)\n                 except Exception as err:\n+                    logger.exception('Exception caught in receiver %r', receiver)\n                     responses.append((receiver, err))\n                 else:\n                     responses.append((receiver, response))\n\n```"}
{"instance_id": "django__django-13925", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -531,6 +531,10 @@\n                     % (field.name, self.pk.name)\n                 )\n             else:\n                 self.pk = field\n+                # An explicit primary key means auto_created is False.\n+                if not getattr(field, 'auto_created', False):\n+                    self.auto_created = False\n \n         if not private:\n             self.fields_map[field.name] = field\n\n```"}
{"instance_id": "django__django-13933", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1154,8 +1154,8 @@\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n-        'invalid_choice': _('Select a valid choice. That choice is not one of'\n-                            ' the available choices.'),\n+        'invalid_choice': _('Select a valid choice. %(value)s is not one of '\n+                            'the available choices.'),\n     }\n     iterator = ModelChoiceIterator\n \n@@ -1183,7 +1183,11 @@\n             key = self.to_field_name or 'pk'\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(\n+                self.error_messages['invalid_choice'],\n+                code='invalid_choice',\n+                params={'value': value},\n+            )\n         return value\n \n     def validate(self, value):\n@@ -1202,8 +1206,6 @@\n     hidden_widget = MultipleHiddenInput\n     default_error_messages = {\n         'invalid_list': _('Enter a list of values.'),\n-        'invalid_choice': _('Select a valid choice. %(value)s is not one of the'\n-                            ' available choices.'),\n         'invalid_pk_value': _('\u201c%(pk)s\u201d is not a valid value.')\n     }\n \n\n```"}
{"instance_id": "django__django-13964", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -933,7 +933,7 @@\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, f.name)\n                     )\n-                elif getattr(self, f.attname) is None:\n+                elif getattr(self, f.attname) in f.empty_values:\n                     # Use pk from related object if it has been saved after\n                     # an assignment.\n                     setattr(self, f.attname, obj.pk)\n\n```"}
{"instance_id": "django__django-14016", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -1,4 +1,3 @@\n-import copy\n from functools import partial\n \n from django.core.exceptions import EmptyResultSet\n@@ -14,24 +13,29 @@\n     OR = 'OR'\n     default = AND\n \n-    def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n-        super().__init__(children=list(args) + list(kwargs.items()),\n-                         connector=_connector, negated=_negated)\n+    def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n+        # Q() is a no-op.\n+        if not args and not kwargs:\n+            super().__init__()\n+            return\n+        # Allow Q(self) to create a clone.\n+        if len(args) == 1 and isinstance(args[0], Q):\n+            q = args[0]\n+            super().__init__(q.children, q.connector, q.negated)\n+            return\n+        super().__init__(list(args) + list(kwargs.items()), _connector, _negated)\n \n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and return a copy of self.\n         if not other:\n-            return copy.deepcopy(self)\n+            return type(self)(self)\n         # Or if this Q is empty, return a copy of the other Q.\n         if not self:\n-            return copy.deepcopy(other)\n+            return type(self)(other)\n \n-        obj = copy.deepcopy(self)\n+        obj = type(self)(self)\n         obj.add(other, conn)\n         return obj\n \n\n```"}
{"instance_id": "django__django-14017", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -88,12 +88,16 @@\n         # This is for backward-compatibility from before Q objects could be\n         # negated.\n         return self.clone()\n \n     def __and__(self, other):\n-        return self._combine(other, self.AND)\n+        if not isinstance(other, Q):\n+            return NotImplemented\n+        return self._combine(other, self.AND)\n \n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.NOT)\n         return obj\n \n     def __or__(self, other):\n-        return self._combine(other, self.OR)\n+        if not isinstance(other, Q):\n+            return NotImplemented\n+        return self._combine(other, self.OR)\n \n     # Connection types\n     AND = 'AND'\n\n```"}
{"instance_id": "django__django-14155", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -2,6 +2,7 @@\n \n import re\n import threading\n+import functools\n import types\n from importlib import import_module\n \n@@ -21,10 +22,27 @@\n         namespaces=None,\n         route=None,\n     ):\n-        self.func = func\n-        self.args = args\n-        self.kwargs = kwargs\n+        # Unwrap functools.partial objects so that the underlying function\n+        # and its pre-applied arguments are exposed in a helpful way.\n+        if isinstance(func, functools.partial):\n+            # This uses the same logic as functools.partial.\n+            # https://docs.python.org/3/library/functools.html#functools.partial\n+            self.func = func.func\n+            self.args = func.args + args\n+            self.kwargs = func.keywords.copy()\n+            self.kwargs.update(kwargs)\n+        else:\n+            self.func = func\n+            self.args = args\n+            self.kwargs = kwargs\n+\n         self.url_name = url_name\n         self.app_names = app_names or []\n         self.namespaces = namespaces or []\n         self.route = route\n \n     def __repr__(self):\n         return (\n@@ -53,7 +71,7 @@\n \n     def _func_path(self):\n         if hasattr(self.func, \"__module__\"):\n-            return \"%s.%s\" % (self.func.__module__, self.func.__name__)\n+            return \"%s.%s\" % (self.func.__module__, getattr(self.func, \"__name__\", repr(self.func)))\n         return repr(self.func)\n \n     @property\n\n```"}
{"instance_id": "django__django-14238", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -171,15 +171,10 @@\n     def __subclasscheck__(self, subclass):\n         # This is needed for issubclass(some_model.pk, AutoField) to work.\n         return any(\n-            # We can't use super().__subclasscheck__() here because it would\n-            # cause a recursion error.\n-            issubclass(subclass, cls.mro()[1])\n+            issubclass(subclass, cls)\n             for cls_name, cls in inspect.getmembers(\n                 sys.modules[self.__module__], inspect.isclass\n             )\n-            if (\n-                cls_name in self._subclasses\n-                and cls is not self\n-                and issubclass(cls, self)\n-            )\n+            if cls_name in self._subclasses and cls is not self\n         ) or super().__subclasscheck__(subclass)\n\n```"}
{"instance_id": "django__django-14382", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/management/templates.py\n+++ b/django/core/management/templates.py\n@@ -76,7 +76,7 @@\n         else:\n             target = os.path.abspath(target)\n             if app_or_project == 'app':\n-                self.validate_name(os.path.basename(target), 'directory')\n+                self.validate_name(os.path.basename(target.rstrip(os.sep)), 'directory')\n \n         base_name = 'app_name' if app_or_project == 'app' else 'project_name'\n         base_subdir = 'app_template' if app_or_project == 'app' else 'project_template'\n\n```"}
{"instance_id": "django__django-14411", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/auth/widgets.py\n+++ b/django/contrib/auth/widgets.py\n@@ -14,6 +14,11 @@\n         self.help_text = kwargs.pop(\"help_text\", self.help_text)\n         super().__init__(attrs)\n \n+    def id_for_label(self, id_):\n+        # This widget isn't a real input, so it should not have a label with a\n+        # \"for\" attribute.\n+        return None\n+\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         context[\"help_text\"] = self.help_text\n\n```"}
{"instance_id": "django__django-14534", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -262,11 +262,12 @@\n         data = kwargs.get('data', self.data)\n         return self.parent_widget.render(data['name'], data['value'], data['attrs'], self.renderer)\n \n-    def id_for_label(self):\n-        \"\"\"\n-        The HTML ID of this widget.\n-\n-        This is temporary until the widget rendering refactor of #22342 is\n-        complete.\n-        \"\"\"\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+    def id_for_label(self):\n+        \"\"\"\n+        Return the ID attribute that should be used on a <label> associated\n+        with this widget. If an explicit id is provided, prefer that.\n+        \"\"\"\n+        attrs = self.data.get('attrs')\n+        if attrs and 'id' in attrs:\n+            return attrs['id']\n+        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n\n```"}
{"instance_id": "django__django-14580", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -271,7 +271,10 @@\n class TypeSerializer(BaseSerializer):\n     def serialize(self):\n         special_cases = [\n-            (models.Model, \"models.Model\", []),\n+            # Ensure models is imported when models.Model is referenced and no\n+            # other field forces this import (e.g. a custom model without any\n+            # built-in Django fields).\n+            (models.Model, \"models.Model\", [\"from django.db import models\"]),\n             (type(None), \"type(None)\", []),\n         ]\n         for case, string, imports in special_cases:\n\n```"}
{"instance_id": "django__django-14608", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -65,7 +65,7 @@\n             try:\n                 self.clean()\n             except ValidationError as e:\n-                self._non_form_errors = self.error_class(e.error_list)\n+                self._non_form_errors = self.error_class(e.error_list, error_class='nonform')\n \n     @property\n     def non_form_errors(self):\n@@ -101,7 +101,7 @@\n         Returns an ErrorList of errors that don't belong to any particular\n         form.\n         \"\"\"\n-        return self.errors.get(NON_FORM_ERRORS, self.error_class())\n+        return self.errors.get(NON_FORM_ERRORS, self.error_class(error_class='nonform'))\n \n     @property\n     def total_error_count(self):\n--- a/docs/topics/forms/formsets.txt\n+++ b/docs/topics/forms/formsets.txt\n@@ -399,6 +399,11 @@\n If you need to access errors in the template without rendering them, you can use\n ``{{ my_formset.non_form_errors }}``.\n \n+The non-form errors are rendered with a ``<ul class=\"errorlist nonform\">`` when\n+you use ``{{ formset.non_form_errors }}`` (``formset`` is the name of your\n+formset context variable).\n+\n Displaying the formset\n ----------------------\n Now, we'll need to display the formset in the template. We could do this::\n\n```"}
{"instance_id": "django__django-14667", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1498,13 +1498,21 @@\n         if not defer:\n             # We are in \"only\" mode. We need to remove any of the fields\n             # from the existing set of \"only\" fields.\n-            new_only = existing.difference(field_names)\n-            if not new_only:\n-                # All \"only\" fields are now deferred, so none are loaded.\n+            fields_to_defer = set(field_names)\n+            new_only = existing.difference(fields_to_defer)\n+            newly_deferred = fields_to_defer.difference(existing)\n+            if not new_only and newly_deferred:\n+                # All \"only\" fields are now deferred, so we switch to defer()\n+                # mode.\n+                self.deferred_loading = (frozenset(newly_deferred), True)\n+                self.add_deferred_loading(list(existing))\n+            elif not new_only:\n+                # All \"only\" fields are now deferred, so all are loaded.\n                 self.deferred_loading = (frozenset(), True)\n-                return\n-            self.deferred_loading = (new_only, False)\n+            else:\n+                self.deferred_loading = (new_only, False)\n             return\n \n         # We are in \"defer\" mode.\n\n```"}
{"instance_id": "django__django-14672", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -234,7 +234,7 @@\n         self.through = through\n         if through_fields is not None and not through:\n             raise ValueError(\"Cannot specify through_fields without a through model\")\n-        self.through_fields = through_fields\n+        self.through_fields = make_hashable(through_fields)\n         self.symmetrical = symmetrical\n         self.db_constraint = db_constraint\n         self.swappable = swappable\n\n```"}
{"instance_id": "django__django-14730", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1629,6 +1629,7 @@\n         errors.extend(self._check_m2m_db_table(**kwargs))\n         errors.extend(self._check_related_name_is_valid(**kwargs))\n         errors.extend(self._check_related_name_unique(**kwargs))\n+        errors.extend(self._check_related_name_with_symmetrical(**kwargs))\n         errors.extend(self._check_reverse_relationship_models(**kwargs))\n         errors.extend(self._check_clashes(**kwargs))\n         errors.extend(self._check_unique(**kwargs))\n@@ -1645,6 +1646,29 @@\n \n     def _check_unique(self, **kwargs):\n         return []\n+\n+    def _check_related_name_with_symmetrical(self, **kwargs):\n+        if (\n+            self.remote_field.symmetrical\n+            and self.remote_field.model == self.model\n+            and self.remote_field.related_name\n+            and self.remote_field.related_name != \"+\"\n+        ):\n+            return [\n+                checks.Error(\n+                    \"The 'related_name' argument is not supported for symmetrical \"\n+                    \"ManyToManyField relationships.\",\n+                    hint=(\n+                        \"Remove the 'related_name' argument from this field, or \"\n+                        \"add 'symmetrical=False' to the field.\"\n+                    ),\n+                    obj=self,\n+                    id=\"fields.E339\",\n+                )\n+            ]\n+        return []\n+\n \n \n class OneToOneField(ForeignKey):\n\n```"}
{"instance_id": "django__django-14752", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -8,34 +8,47 @@\n \n \n class AutocompleteJsonView(View):\n+    \"\"\"\n+    Return a JsonResponse for ForeignKey and ManyToManyField autocompletes\n+    used by the admin.\n+\n+    The default implementation serializes each model instance with its primary\n+    key (or the value of the ``to_field`` set on the relation) and its string\n+    representation. Subclasses can add extra attributes to every result item\n+    by overriding :meth:`serialize_result` instead of reimplementing the whole\n+    :meth:`get` method.\n+    \"\"\"\n+\n     def get(self, request, *args, **kwargs):\n         (\n             self.term,\n             self.model_admin,\n             self.source_field,\n             to_field_name,\n         ) = self.process_request(request)\n \n         if not self.has_perm(request):\n             raise PermissionDenied\n \n         self.object_list = self.get_queryset()\n         context = self.get_context_data()\n         return JsonResponse(\n             {\n                 \"results\": [\n-                    {\"id\": str(getattr(obj, to_field_name)), \"text\": str(obj)}\n+                    self.serialize_result(obj, to_field_name)\n                     for obj in context[\"object_list\"]\n                 ],\n                 \"pagination\": {\"more\": context[\"page_obj\"].has_next()},\n             }\n         )\n \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"\n+        Convert *obj* to a dictionary representation suitable for inclusion in\n+        the JSON results list returned by :meth:`get`.\n+\n+        The returned mapping must include at least the ``id`` and ``text``\n+        keys expected by Select2. The default implementation exposes the\n+        object's identifier and its string representation.\n+        \"\"\"\n+        return {\"id\": str(getattr(obj, to_field_name)), \"text\": str(obj)}\n+\n     def get_paginator(\n         self, queryset, page_size, orphans=0, allow_empty_first_page=True\n     ):\n\n```"}
{"instance_id": "django__django-14787", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -125,14 +125,15 @@\n     # `self` is the object instance.\n     def _dec(func):\n         def _wrapper(self, *args, **kwargs):\n-            # In _wrapper, `func` is a function, `self` is an object.\n-            # The following expression is calling `decorator` with a bound method\n-            # `func(self, ...)`. `decorator` returns a function, which is\n-            # then called with `*args` and `**kwargs`.\n-            return decorator(partial(func, self))(*args, **kwargs)\n+            # bound_func is a bound method, i.e. a mapping of `func` to `self`.\n+            bound_func = partial(func, self)\n+            # `update_wrapper()` can be used to copy attributes from `func` to\n+            # `bound_func` but not `__dict__` because `partial` objects don't\n+            # have one.\n+            update_wrapper(bound_func, func, updated=())\n+            # Pass the bound method to the decorator.\n+            return decorator(bound_func)(*args, **kwargs)\n \n-        # update_wrapper() doesn't work on partial objects.\n         return wraps(func)(_wrapper)\n \n     return _dec\n\n```"}
{"instance_id": "django__django-14855", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/contrib/admin/helpers.py\n+++ b/django/contrib/admin/helpers.py\n@@ -349,7 +349,11 @@\n         )\n         try:\n             # Don't use relative URLs...\n-            url = reverse(url_name, args=[quote(remote_obj.pk)])\n+            url = reverse(\n+                url_name,\n+                args=[quote(remote_obj.pk)],\n+                current_app=self.model_admin.admin_site.name,\n+            )\n         except NoReverseMatch:\n             return None\n         return url\n\n```"}
{"instance_id": "django__django-14915", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/forms/models.py b/django/forms/models.py\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1191,6 +1191,9 @@\n         if isinstance(other, ModelChoiceIteratorValue):\n             other = other.value\n         return self.value == other\n+\n+    def __hash__(self):\n+        return hash(self.value)\n \n     def __getattr__(self, name):\n         return getattr(self.instance, name)\n\n```"}
{"instance_id": "django__django-14997", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -375,9 +375,11 @@\n         When we create a new table, we need to update all references to the old\n         table name with the new one.\n         \"\"\"\n+        if self.alias is None:\n+            return\n         if hasattr(self, \"target\") and hasattr(self.target, \"model\"):\n-            if self.target.model._meta.db_table == old_table:\n+            if self.alias == old_table:\n                 self.alias = new_table\n \n     def get_group_by_cols(self, alias=None):\n         if not self.contains_aggregate:\n\n```"}
{"instance_id": "django__django-14999", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -310,29 +310,32 @@\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         from_model = from_state.apps.get_model(app_label, self.old_name)\n         to_model = to_state.apps.get_model(app_label, self.new_name)\n-        schema_editor.alter_db_table(from_model, from_model._meta.db_table, to_model._meta.db_table)\n-        # Rename M2M fields whose name doesn't change.\n-        self._rename_many_to_many_tables(\n-            from_model, to_model, schema_editor, lambda x: x\n-        )\n+        # If the table name hasn't changed (i.e. a static db_table is used),\n+        # there's no database work to do for the main model or its auto-created\n+        # many-to-many tables.\n+        if from_model._meta.db_table != to_model._meta.db_table:\n+            schema_editor.alter_db_table(\n+                from_model, from_model._meta.db_table, to_model._meta.db_table\n+            )\n+            # Rename M2M fields whose name doesn't change.\n+            self._rename_many_to_many_tables(\n+                from_model, to_model, schema_editor, lambda x: x\n+            )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n         from_model = from_state.apps.get_model(app_label, self.new_name)\n         to_model = to_state.apps.get_model(app_label, self.old_name)\n-        schema_editor.alter_db_table(from_model, from_model._meta.db_table, to_model._meta.db_table)\n-        # Rename M2M fields whose name doesn't change.\n-        self._rename_many_to_many_tables(\n-            from_model, to_model, schema_editor, lambda x: x\n-        )\n+        if from_model._meta.db_table != to_model._meta.db_table:\n+            schema_editor.alter_db_table(\n+                from_model, from_model._meta.db_table, to_model._meta.db_table\n+            )\n+            # Rename M2M fields whose name doesn't change.\n+            self._rename_many_to_many_tables(\n+                from_model, to_model, schema_editor, lambda x: x\n+            )\n \n     def _rename_many_to_many_tables(self, from_model, to_model, schema_editor, transform):\n         # Rename M2M auto-created tables.\n@@ -346,10 +349,11 @@\n             new_field = to_model._meta.get_field(field.name)\n             if not new_field.remote_field.through._meta.auto_created:\n                 continue\n-            schema_editor.alter_db_table(\n-                field.remote_field.through,\n-                transform(field.remote_field.through._meta.db_table),\n-                new_field.remote_field.through._meta.db_table,\n-            )\n+            if field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:\n+                schema_editor.alter_db_table(\n+                    field.remote_field.through,\n+                    transform(field.remote_field.through._meta.db_table),\n+                    new_field.remote_field.through._meta.db_table,\n+                )\n \n     def describe(self):\n         return \"Rename model %s to %s\" % (self.old_name, self.new_name)\n\n```"}
{"instance_id": "django__django-15061", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -654,7 +654,5 @@\n         return context\n \n     def id_for_label(self, id_):\n-        # See the comment for RadioSelect.id_for_label()\n-        if id_:\n-            return f\"{id_}_0\"\n-        return \"\"\n+        # A MultiWidget is a list of widgets, each with their own label.\n+        # The whole MultiWidget doesn't get a single label, so this method\n+        # should not be used.\n+        return \"\"\n\n```"}
{"instance_id": "django__django-15202", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -126,10 +126,14 @@\n     def __call__(self, value):\n         if not isinstance(value, str):\n             raise ValidationError(self.message, code=self.code)\n+        try:\n+            url_parts = urlsplit(value)\n+        except ValueError:\n+            raise ValidationError(self.message, code=self.code)\n         # Check if the scheme is valid.\n-        scheme = urlsplit(value).scheme\n-        if scheme not in self.schemes:\n-            if scheme:\n+        if url_parts.scheme not in self.schemes:\n+            if url_parts.scheme:\n                 message = self.message\n             else:\n                 message = _('URL scheme must be http, https, ftp, or ftps.')\n@@ -148,7 +152,7 @@\n                 raise\n \n         # Now verify IPv6 in the netloc part.\n-        host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', urlsplit(value).netloc)\n+        host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', url_parts.netloc)\n         if host_match:\n             potential_ip = host_match.groups()[0]\n             try:\n@@ -160,6 +164,6 @@\n         # section 3.1. It's defined to be 255 bytes or less, but this includes\n         # one byte for the length of the name and one byte for the trailing dot\n         # that's used to indicate absolute names in DNS.\n-        if len(urlsplit(value).netloc) > 253:\n+        if len(url_parts.netloc) > 253:\n             raise ValidationError(self.message, code=self.code)\n\n```"}
{"instance_id": "django__django-15213", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -94,12 +94,20 @@\n             # counts.\n             if empty_needed == 0:\n                 if self.negated:\n+                    if self.resolved:\n+                        # When used as an expression, return a valid true\n+                        # expression.\n+                        return '1', []\n                     return '', []\n                 else:\n                     raise EmptyResultSet\n             elif full_needed == 0:\n                 if self.negated:\n                     raise EmptyResultSet\n                 else:\n+                    if self.resolved:\n+                        # When used as an expression, return a valid false\n+                        # expression.\n+                        return '0', []\n                     return '', []\n         conn = ' %s ' % self.connector\n         sql_string = conn.join(result)\n\n```"}
{"instance_id": "django__django-15252", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -1,5 +1,5 @@\n from django.apps.registry import Apps\n-from django.db import models\n+from django.db import models, router\n from django.utils.timezone import now\n \n \n@@ -40,25 +40,31 @@\n         \"\"\"\n         # If the table's there, that's fine - we've never changed its schema\n         # in the codebase.\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         if self.has_table():\n             return\n         # Make the table\n         with self.connection.schema_editor() as editor:\n             editor.create_model(self.Migration)\n \n     def applied_migrations(self):\n         \"\"\"\n         Returns a set of (app, name) of applied migrations.\n         \"\"\"\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return set()\n         self.ensure_schema()\n         return set(tuple(x) for x in self.Migration.objects.using(self.connection.alias).values_list(\"app\", \"name\"))\n \n     def record_applied(self, app, name):\n         \"\"\"\n         Records a migration as having been applied.\n         \"\"\"\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.Migration.objects.using(self.connection.alias).create(app=app, name=name)\n \n     def record_unapplied(self, app, name):\n         \"\"\"\n         Records a migration as having been unapplied.\n         \"\"\"\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.Migration.objects.using(self.connection.alias).filter(app=app, name=name).delete()\n\n```"}
{"instance_id": "django__django-15320", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1145,8 +1145,13 @@\n     template = '(%s)'\n \n     def __init__(self, queryset, output_field=None, **extra):\n-        self.query = queryset.query\n+        # Clone the underlying query and mark it as a subquery.\n+        self.query = queryset.query.clone()\n+        self.query.subquery = True\n         self.output_field = output_field\n         self.extra = extra\n \n     def __getstate__(self):\n\n```"}
{"instance_id": "django__django-15347", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/contrib/messages/storage/cookie.py b/django/contrib/messages/storage/cookie.py\n--- a/django/contrib/messages/storage/cookie.py\n+++ b/django/contrib/messages/storage/cookie.py\n@@ -26,7 +26,7 @@\n             # Using 0/1 here instead of False/True to produce more compact json\n             is_safedata = 1 if isinstance(obj.message, SafeData) else 0\n             message = [self.message_key, is_safedata, obj.level, obj.message]\n-            if obj.extra_tags:\n+            if obj.extra_tags is not None:\n                 message.append(obj.extra_tags)\n             return message\n         return super(MessageEncoder, self).default(obj)\n\n```"}
{"instance_id": "django__django-15388", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -50,6 +50,11 @@\n \n @receiver(file_changed, dispatch_uid=\"template_loaders_file_changed\")\n def template_changed(sender, file_path, **kwargs):\n+    # Let the autoreloader trigger a full reload for Python source/byte-code\n+    # files even if they're located inside a template directory.\n+    if file_path.suffix in {\".py\", \".pyc\", \".pyo\"}:\n+        return\n+\n     for template_dir in get_template_directories():\n         if template_dir in file_path.parents:\n             reset_loaders()\n\n```"}
{"instance_id": "django__django-15400", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/utils/functional.py b/django/utils/functional.py\n--- a/django/utils/functional.py\n+++ b/django/utils/functional.py\n@@ -366,6 +366,11 @@ class LazyObject:\n     __ne__ = new_method_proxy(operator.ne)\n     __hash__ = new_method_proxy(hash)\n \n+    # Arithmetic operators\n+    __add__ = new_method_proxy(operator.add)\n+    __radd__ = new_method_proxy(lambda a, b: operator.add(b, a))\n+\n     # List/Tuple/Dictionary methods support\n     __getitem__ = new_method_proxy(operator.getitem)\n     __setitem__ = new_method_proxy(operator.setitem)\n\n```"}
{"instance_id": "django__django-15498", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/views/static.py b/django/views/static.py\n--- a/django/views/static.py\n+++ b/django/views/static.py\n@@ -129,6 +129,8 @@ def was_modified_since(header=None, mtime=0, size=0):\n     if header is None:\n         raise ValueError\n     matches = re.match(r\"^([^;]+)(; length=([0-9]+))?$\", header, re.IGNORECASE)\n+    if not matches:\n+        raise ValueError\n     header_mtime = parse_http_date(matches[1])\n     header_len = matches[3]\n     if header_len and int(header_len) != size:\n\n```"}
{"instance_id": "django__django-15695", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -967,8 +967,19 @@\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n         if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n-            return\n+            model = from_state.apps.get_model(app_label, self.model_name)\n+            if not self.allow_migrate_model(schema_editor.connection.alias, model):\n+                return\n+            from_model_state = from_state.models[app_label, self.model_name_lower]\n+            renamed_index = from_model_state.get_index_by_name(self.new_name)\n+            columns = [model._meta.get_field(field).column for field in self.old_fields]\n+            original_index_name = schema_editor._create_index_name(\n+                model._meta.db_table, columns\n+            )\n+            old_index = renamed_index.clone()\n+            old_index.name = original_index_name\n+            schema_editor.rename_index(model, renamed_index, old_index)\n+            return\n \n         self.new_name_lower, self.old_name_lower = (\n             self.old_name_lower,\n\n```"}
{"instance_id": "django__django-15738", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -188,6 +188,11 @@\n         # Generate field renaming operations.\n         self.generate_renamed_fields()\n         self.generate_renamed_indexes()\n+        # Detect fields that need to be removed and re-added due to type changes.\n+        # This must be done before generate_removed_fields/generate_added_fields\n+        # to ensure operations are created in the correct order.\n+        self._detect_field_type_changes()\n+\n         # Generate removal of foo together.\n         self.generate_removed_altered_unique_together()\n         self.generate_removed_altered_index_together()\n@@ -1013,9 +1018,45 @@\n             for name, field in sorted(related_fields.items())\n         ]\n \n+    def _detect_field_type_changes(self):\n+        \"\"\"\n+        Detect fields that are in both old and new state but have incompatible\n+        types that require removal and re-addition (e.g., ForeignKey to\n+        ManyToManyField).\n+        \"\"\"\n+        self.field_type_change_removals = set()\n+        self.field_type_change_additions = set()\n+\n+        for app_label, model_name, field_name in sorted(\n+            self.old_field_keys & self.new_field_keys\n+        ):\n+            old_model_name = self.renamed_models.get(\n+                (app_label, model_name), model_name\n+            )\n+            old_field_name = self.renamed_fields.get(\n+                (app_label, model_name, field_name), field_name\n+            )\n+            old_field = self.from_state.models[app_label, old_model_name].get_field(\n+                old_field_name\n+            )\n+            new_field = self.to_state.models[app_label, model_name].get_field(\n+                field_name\n+            )\n+\n+            # Check if we can alter between these field types.\n+            old_field_dec = self.deep_deconstruct(old_field)\n+            new_field_dec = self.deep_deconstruct(new_field)\n+            if old_field_dec != new_field_dec and old_field_name == field_name:\n+                both_m2m = old_field.many_to_many and new_field.many_to_many\n+                neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n+                if not (both_m2m or neither_m2m):\n+                    # We cannot alter between m2m and concrete fields.\n+                    # Mark for removal and re-addition.\n+                    self.field_type_change_removals.add((app_label, model_name, field_name))\n+                    self.field_type_change_additions.add((app_label, model_name, field_name))\n+\n     def generate_added_fields(self):\n         \"\"\"Make AddField operations.\"\"\"\n         for app_label, model_name, field_name in sorted(\n-            self.new_field_keys - self.old_field_keys\n+            (self.new_field_keys - self.old_field_keys) | self.field_type_change_additions\n         ):\n             self._generate_added_field(app_label, model_name, field_name)\n \n@@ -1073,7 +1114,8 @@\n     def generate_removed_fields(self):\n         \"\"\"Make RemoveField operations.\"\"\"\n         for app_label, model_name, field_name in sorted(\n-            self.old_field_keys - self.new_field_keys\n+            (self.old_field_keys - self.new_field_keys) |\n+            self.field_type_change_removals\n         ):\n             self._generate_removed_field(app_label, model_name, field_name)\n \n@@ -1101,6 +1143,10 @@\n         for app_label, model_name, field_name in sorted(\n             self.old_field_keys & self.new_field_keys\n         ):\n+            # Skip fields that need type changes - already handled.\n+            if (app_label, model_name, field_name) in self.field_type_change_removals:\n+                continue\n+\n             # Did the field change?\n             old_model_name = self.renamed_models.get(\n                 (app_label, model_name), model_name\n@@ -1209,9 +1255,8 @@\n                         field=new_field_dec,\n                     )\n                 else:\n-                    # We cannot alter between m2m and concrete fields\n-                    self._generate_removed_field(app_label, model_name, field_name)\n-                    self._generate_added_field(app_label, model_name, field_name)\n+                    # This should have been handled by _detect_field_type_changes.\n+                    pass\n \n     def create_altered_indexes(self):\n         option_name = operations.AddIndex.option_name\n\n```"}
{"instance_id": "django__django-15781", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/core/management/base.py b/django/core/management/base.py\nindex f0e711ac76..e60c7e289c 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -285,16 +285,17 @@ class BaseCommand:\n     help = \"\"\n     _called_from_command_line = False\n \n-    def create_parser(self, prog_name, subcommand):\n+    def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n         parse the arguments to this command.\n         \"\"\"\n+        kwargs.setdefault(\"formatter_class\", DjangoHelpFormatter)\n         parser = CommandParser(\n             prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n             description=self.help or None,\n-            formatter_class=DjangoHelpFormatter,\n             missing_args_message=getattr(self, \"missing_args_message\", None),\n             called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n+            **kwargs,\n         )\n         parser.add_argument(\"--version\", action=\"version\", version=self.get_version())\n         self.add_base_argument(parser)\n\n```"}
{"instance_id": "django__django-15789", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -59,15 +59,19 @@\n }\n \n \n-def json_script(value, element_id):\n+def json_script(value, element_id, encoder=None):\n     \"\"\"\n     Escape all the HTML/XML special characters with their unicode escapes, so\n     value is safe to be output anywhere except for inside a tag attribute. Wrap\n-    the escaped JSON in a script tag.\n+    the escaped JSON in a script tag.\n+\n+    The 'encoder' parameter allows passing a custom JSON encoder class.\n     \"\"\"\n     from django.core.serializers.json import DjangoJSONEncoder\n \n-    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n+    if encoder is None:\n+        encoder = DjangoJSONEncoder\n+    json_str = json.dumps(value, cls=encoder).translate(_json_script_escapes)\n     return format_html(\n         '<script id=\"{}\" type=\"application/json\">{}</script>', element_id, mark_safe(json_str)\n     )\n--- a/docs/ref/utils.txt\n+++ b/docs/ref/utils.txt\n@@ -325,6 +325,37 @@\n :ref:`cross-site-scripting` for more information.\n \n \n+``json_script(value, element_id, encoder=None)``\n+-------------------------------------------------\n+\n+.. versionadded:: 1.11\n+\n+.. versionchanged:: 4.2\n+\n+    The ``encoder`` parameter was added.\n+\n+This function is similar to ``json.dumps()`` but it escapes characters that\n+would terminate an HTML ``<script>`` tag. It's for use in generating JSON that\n+will be embedded in an HTML ``<script>`` tag. It returns a ``<script>`` tag\n+with the JSON-encoded ``value``, ready for embedding in an HTML document.\n+For example::\n+\n+    <script id=\"my-data\" type=\"application/json\">{\"key\": \"value\"}</script>\n+\n+This is useful for avoiding the need to manually escape HTML special characters\n+in the JSON. For example, if you have a dictionary ``{\"<foo>\": \"bar'baz\"}``,\n+``json.dumps()`` would return ``'{\"<foo>\": \"bar\\'baz\"}'``. Without escaping, this\n+would be invalid in a ``<script>`` tag. With ``json_script()``, it becomes::\n+\n+    <script id=\"my-data\" type=\"application/json\">{\"\\u003cfoo\\u003e\": \"bar'baz\"}</script>\n+\n+Its output is safe for use in HTML. ``element_id`` is the ID for the resulting\n+``<script>`` tag.\n+\n+By default, it uses ``django.core.serializers.json.DjangoJSONEncoder`` to encode\n+the ``value``. You can use a different encoder by passing it as the ``encoder``\n+argument.\n+\n+A template filter version, :tfilter:`json_script`, is also available.\n+\n ``linebreaks(value, autoescape=False)``\n ---------------------------------------\n \n\n```"}
{"instance_id": "django__django-15790", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/core/checks/templates.py b/django/core/checks/templates.py\n--- a/django/core/checks/templates.py\n+++ b/django/core/checks/templates.py\n@@ -50,19 +50,19 @@\n @register(Tags.templates)\n def check_for_template_tags_with_the_same_name(app_configs, **kwargs):\n     errors = []\n-    libraries = defaultdict(list)\n+    libraries = defaultdict(set)\n \n     for conf in settings.TEMPLATES:\n         custom_libraries = conf.get(\"OPTIONS\", {}).get(\"libraries\", {})\n         for module_name, module_path in custom_libraries.items():\n-            libraries[module_name].append(module_path)\n+            libraries[module_name].add(module_path)\n \n     for module_name, module_path in get_template_tag_modules():\n-        libraries[module_name].append(module_path)\n+        libraries[module_name].add(module_path)\n \n     for library_name, items in libraries.items():\n         if len(items) > 1:\n             errors.append(\n                 Error(\n                     E003.msg.format(\n                         repr(library_name),\n-                        \", \".join(repr(item) for item in items),\n+                        \", \".join(repr(item) for item in sorted(items)),\n                     ),\n                     id=E003.id,\n                 )\n\n```"}
{"instance_id": "django__django-15814", "model_name_or_path": "parallelsynthetize_router", "model_patch": "```diff\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -768,7 +768,13 @@\n                 else:\n                     cur_model = model\n \n-            opts = cur_model._meta\n+            # Ensure that we always work with the concrete model when\n+            # traversing relations. If ``cur_model`` is a proxy model,\n+            # switching to its concrete model avoids missing primary key\n+            # columns in the select list which can lead to crashes when\n+            # combining ``select_related()`` with ``only()`` (see #33783).\n+            cur_model = cur_model._meta.concrete_model\n+            opts = cur_model._meta\n             if alias_chain is None:\n                 alias_chain = []\n \n\n```"}
